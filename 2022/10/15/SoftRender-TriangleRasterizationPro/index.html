<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Software Rasterizer - Triangle Rasterization Pro | Canned Pixels</title><meta name="author" content="Zishuai Zhang,zhangzs2023@163.com"><meta name="copyright" content="Zishuai Zhang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="IntroductionPerfect mathematical triangle that only exists in our minds, but perfect precise triangles they don’t exist in the real world, we need to rasterize in discrete pixel by pixel raster. Scanl">
<meta property="og:type" content="article">
<meta property="og:title" content="Software Rasterizer - Triangle Rasterization Pro">
<meta property="og:url" content="https://zhangzs11.github.io/2022/10/15/SoftRender-TriangleRasterizationPro/index.html">
<meta property="og:site_name" content="Canned Pixels">
<meta property="og:description" content="IntroductionPerfect mathematical triangle that only exists in our minds, but perfect precise triangles they don’t exist in the real world, we need to rasterize in discrete pixel by pixel raster. Scanl">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://zhangzs11.github.io/img/MyAvatar.jpg">
<meta property="article:published_time" content="2022-10-15T06:00:00.000Z">
<meta property="article:modified_time" content="2025-02-03T02:55:39.920Z">
<meta property="article:author" content="Zishuai Zhang">
<meta property="article:tag" content="Computer Graphics, D3D, Game Engine Development">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhangzs11.github.io/img/MyAvatar.jpg"><link rel="shortcut icon" href="/img/MyAvatar.jpg"><link rel="canonical" href="https://zhangzs11.github.io/2022/10/15/SoftRender-TriangleRasterizationPro/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Software Rasterizer - Triangle Rasterization Pro',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background: linear-gradient(20deg, #b9fbc0, #98f5e1, #90dbf4, #cfbaf0);"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/Funny/sunsetflower.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Canned Pixels</span></a><a class="nav-page-title" href="/"><span class="site-name">Software Rasterizer - Triangle Rasterization Pro</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Software Rasterizer - Triangle Rasterization Pro<a class="post-edit-link" href="null_posts/SoftRender-TriangleRasterizationPro.md" title="Edit" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-10-15T06:00:00.000Z" title="Created 2022-10-15 00:00:00">2022-10-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-02-03T02:55:39.920Z" title="Updated 2025-02-02 19:55:39">2025-02-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Software-Rasterizer/">Software Rasterizer</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Perfect mathematical triangle that only exists in our minds, but perfect precise triangles they don’t exist in the real world, we need to rasterize in discrete pixel by pixel raster.</p>
<h1 id="Scanline-rasterizer"><a href="#Scanline-rasterizer" class="headerlink" title="Scanline rasterizer"></a>Scanline rasterizer</h1><p>We start this problem is we analyze three vertices and then we divide the triangle in the middle, and raster and paint all the pixels from the top vertex until the middle of the triangle and then from the middle until the last vertex.<br>We look at the edges of the triangle, looking at the slope of the edge. Slopes are going to determine how are we going to navigate the edge from the top to bottom. We go one scan line down, we look at the slope left and right, slope is going to give us the <strong>start</strong> and the <strong>end</strong>, and then we paint <strong>fill</strong> those pixels in that scan line<br>As we reach the mid part (top triangle finish), we are gonna have to find different slopes, and then still keep finding the start pixel and the end pixel, filling the scanline until find the bottom vertex.</p>
<h1 id="Another-rasterizer-which-is-appropriate-for-GPU"><a href="#Another-rasterizer-which-is-appropriate-for-GPU" class="headerlink" title="Another rasterizer which is appropriate for GPU"></a>Another rasterizer which is appropriate for GPU</h1><p>CPU knows how to execute instructions one after the other linearly, linealy means this instruction depends on the result of the previous one, the previous one depends on the result of even the previous one, everything is sequential.<br>GPU execute things in parallel, the idea is to divide and conquer. It can execute multiple instructions at the same time. most of the computations can be performed simultaneously </p>
<h2 id="High-level-overview"><a href="#High-level-overview" class="headerlink" title="High-level overview"></a>High-level overview</h2><h3 id="Important-Primitives"><a href="#Important-Primitives" class="headerlink" title="Important Primitives"></a>Important Primitives</h3><p>Remember in this case:  </p>
<ul>
<li>We decide vertices in clockwise order.</li>
<li>The Y coordinates grows down on the screen.</li>
<li>The stage we are right here, we ignore everything happened before, all the 3D object transformation, projection, we did with 3D objects before. Just think <strong>we are already in the screen space (the vertices is in screen coordinate)</strong>, the triangle was already projected on the screen. We just focus the rasterization stage.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">float</span> x, y;</span><br><span class="line">&#125; <span class="type">vec2_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">vec2_t</span> vertices[<span class="number">3</span>] = &#123;</span><br><span class="line">    &#123;.x = <span class="number">10</span>, .y =  <span class="number">2</span>&#125;,</span><br><span class="line">    &#123;.x = <span class="number">20</span>, .y = <span class="number">28</span>&#125;,</span><br><span class="line">    &#123;.x =  <span class="number">3</span>, .y = <span class="number">21</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Find-a-bounding-box-with-all-the-candidate-pixels"><a href="#Find-a-bounding-box-with-all-the-candidate-pixels" class="headerlink" title="Find a bounding box with all the candidate pixels"></a>Find a bounding box with all the candidate pixels</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x_min = <span class="built_in">min</span>(v<span class="number">0.</span>x, v<span class="number">1.</span>x, v<span class="number">2.</span>x);</span><br><span class="line"><span class="type">int</span> y_min = <span class="built_in">min</span>(v<span class="number">0.</span>y, v<span class="number">1.</span>y, v<span class="number">2.</span>y);</span><br><span class="line"><span class="type">int</span> x_max = <span class="built_in">max</span>(v<span class="number">0.</span>x, v<span class="number">1.</span>x, v<span class="number">2.</span>x);</span><br><span class="line"><span class="type">int</span> y_max = <span class="built_in">max</span>(v<span class="number">0.</span>y, v<span class="number">1.</span>y, v<span class="number">2.</span>y);</span><br></pre></td></tr></table></figure>
<h3 id="Loop-all-candidate-pixels-in-the-bounding-box"><a href="#Loop-all-candidate-pixels-in-the-bounding-box" class="headerlink" title="Loop all candidate pixels in the bounding box"></a>Loop all candidate pixels in the bounding box</h3><p>From y minimum to y maximum, and then loop from x minimum until x maximum, one by one discretely, I create a new vector2 p and then test is that point inside the triangle. If it is inside, draw that pixel<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> y = y_min; y &lt;= y_max; y++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x = x_min; x &lt;= x_max; x++) &#123;</span><br><span class="line">        <span class="type">vec2_t</span> p = &#123;x, y&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>((<span class="built_in">POINT_INSIDE_TRIANGLE</span>(p))) &#123;</span><br><span class="line">            <span class="built_in">put_pixel</span> (x, y, COLOR);  <span class="comment">// paint with some color</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="How-to-determine-if-a-point-is-inside-or-outside-a-triangle"><a href="#How-to-determine-if-a-point-is-inside-or-outside-a-triangle" class="headerlink" title="How to determine if a point is inside or outside a triangle"></a>How to determine if a point is inside or outside a triangle</h2><p>In our clockwise order, if point <em>P</em> is to the <strong>right</strong> of <strong>all three vectors</strong> of our triangle edges, the <em>P</em> is inside the triangle.<br>If point <em>P</em> is to the left of at least one of the vectors, then P is outside the triangle.</p>
<h3 id="3D-vector-CROSS-product"><a href="#3D-vector-CROSS-product" class="headerlink" title="3D vector CROSS product"></a>3D vector CROSS product</h3><p>Use 3D vector CROSS product to define if something is to the left or to the right of a certain vector<br>CROSS product is usually only defined in the three dimensions. The cross product between Vector A and Vector B is going to result in a new vector that is <strong>perpendicular</strong> with A and B.<br>How do we determine if something is to the right or to the left? Because depending if B is to the left or to the right of A, that cross product is going to change its size and magnitude, <strong>positive</strong> or <strong>negative</strong>.</p>
<div align="center">
  <img src="/images/SoftRender/cross_equation.png" alt="Game Screenshot">
  <p>Cross Product</p>
</div>

<div align="center">
  <img src="/images/SoftRender/cross_magnitude.png" alt="Game Screenshot">
  <p>Magnitude of Cross Product</p>
</div>

<div align="center">
  <img src="/images/SoftRender/crossNotCommutative.png" alt="Game Screenshot">
  <p>Direction of Cross Product</p>
</div>

<h3 id="2D-vector-Cross-product"><a href="#2D-vector-Cross-product" class="headerlink" title="2D vector Cross product"></a>2D vector Cross product</h3><p>(even though in 3D space, we still only need X, Y, to calculate Z component, so in 2D space, even though we only have x, y, we can get the <strong>Z</strong> of cross product)<br>Programmers kind of cheat the cross product in 2D, as this result arrow pointing perpendicular to the screen. 2D cross product can be thought of as the z component of the imaginary vector that is perpendicular to the screen plane. So it is going to be shooting positive or negative. </p>
<div align="center">
  <img src="/images/SoftRender/zCross.png" alt="Game Screenshot">
  <p>z component of Cross</p>
</div>

<p>In the function, we are going to compute the three cross product between the point and the edge<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">edge_cross</span><span class="params">(<span class="type">vec2_t</span>* a, <span class="type">vec2_t</span>* b, <span class="type">vec2_t</span>* p)</span> </span>&#123;</span><br><span class="line">    <span class="type">vec2_t</span> ab = &#123;b-&gt;x - a-&gt;x, b-&gt;y - a-&gt;y&#125;;</span><br><span class="line">    <span class="type">vec2_t</span> ap = &#123;p-&gt;x - a-&gt;x, p-&gt;y - a-&gt;y&#125;;</span><br><span class="line">    <span class="keyword">return</span> ab.x * ap.y - ab.y * ap.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>We should pay attention here the result of the function is an integer value. We are only visiting integer pixel so far, integer from X minimum, max, Y minimum, max, everything in this bounding box is pixel by pixel.<br>So the edge cross result is actually going to be an integer value as well.<br>like:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x_min = <span class="built_in">min</span>(v<span class="number">0.</span>x, v<span class="number">1.</span>x, v<span class="number">2.</span>x);</span><br><span class="line"><span class="type">int</span> y_min = <span class="built_in">min</span>(v<span class="number">0.</span>y, v<span class="number">1.</span>y, v<span class="number">2.</span>y);</span><br><span class="line"><span class="type">int</span> x_max = <span class="built_in">max</span>(v<span class="number">0.</span>x, v<span class="number">1.</span>x, v<span class="number">2.</span>x);</span><br><span class="line"><span class="type">int</span> y_max = <span class="built_in">max</span>(v<span class="number">0.</span>y, v<span class="number">1.</span>y, v<span class="number">2.</span>y);</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> y = y_min; y &lt;= y_max; y++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x = x_min; x &lt;= x_max; x++) &#123;</span><br><span class="line">        <span class="type">vec2_t</span> p = &#123;x, y&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>Calculate the cross, and determine if inside<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> w0 = <span class="built_in">edge_cross</span>(&amp;v1, &amp;v2, &amp;p);</span><br><span class="line"><span class="type">int</span> w1 = <span class="built_in">edge_cross</span>(&amp;v2, &amp;v0, &amp;p);</span><br><span class="line"><span class="type">int</span> w2 = <span class="built_in">edge_cross</span>(&amp;v0, &amp;v1, &amp;p);</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> is_inside = w0 &gt;= <span class="number">0</span> &amp;&amp; w1 &gt;= <span class="number">0</span> &amp;&amp; w2 &gt;= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (is_inside) &#123;</span><br><span class="line">    <span class="built_in">draw_pixel</span>(x, y, color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="Fill-Convention-Rule-Top-Left-rule"><a href="#Fill-Convention-Rule-Top-Left-rule" class="headerlink" title="Fill Convention Rule (Top-Left rule)"></a>Fill Convention Rule (Top-Left rule)</h2><p><strong>Top-Left Rule</strong>: A pixel center is defined to lie inside a triangle if it lies on a <strong><em>flat</em> top</strong> edge or a <strong>left</strong> edge od a triangle.</p>
<div align="center">
  <img src="/images/SoftRender/top-left rule.png" alt="Game Screenshot">
  <p>Top-Left rule</p>
</div>

<h3 id="How-do-I-know-if-a-edge-is-a-flat-top-edge-or-left-edge"><a href="#How-do-I-know-if-a-edge-is-a-flat-top-edge-or-left-edge" class="headerlink" title="How do I know if a edge is a flat top edge or left edge?"></a>How do I know if a edge is a flat top edge or left edge?</h3><p>To be a perfectly flat top edge, the Y values from start to end, they need to be exactly the same, so the edge Y should be zero. And also the edge X needs to be positive, pointing to the right(in clockwise configuration)<br>WHen talking about a clockwise orientation, all the edges that are they will be pointing up, so the Y component is negative(in our case, screen down is positive Y)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_top_left</span><span class="params">(<span class="type">vec2_t</span>* start, <span class="type">vec2_t</span>* end)</span> </span>&#123;</span><br><span class="line">    <span class="type">vec2_t</span> egde = &#123; end-&gt;x - start-&gt;x, end-&gt;y - start-&gt;y &#125;;</span><br><span class="line">    <span class="type">bool</span> is_top_edge = edge.y == <span class="number">0</span> &amp;&amp; edge.x &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> is_left_edge = edge.y &lt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> is_top_edge || is_left_edge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>How to use this function?<br>Before loop the Bounding Box pixel, calculate the bias, don’t need to calculate every pixel.</p>
<p>If I always add minus 1, everything gets squeezed pushed almost to the center to the triangle, by pushing things that are not top or left to the center of triangle, I basically remove that right or bottom edge.<br>As soon as I minus 1 when calculate the w when it’s at edge but not left-top edge, the <code>is_side</code> test become false and we do not draw this pixel.<br>Remember : this offset of <strong>minus one</strong> super easy so far, because we are only talking about integer pixel coordinates. Our vertices are always snapping to the raster grid. There is no floating Point, everything is integer pixel based.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> bias0 = <span class="built_in">is_top_left</span>(&amp;v1, &amp;v2) ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> bias1 = <span class="built_in">is_top_left</span>(&amp;v2, &amp;v0) ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> bias2 = <span class="built_in">is_top_left</span>(&amp;v0, &amp;v1) ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> y = y_min; y &lt;= y_max; y++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x = x_min; x &lt;= x_max; x++) &#123;</span><br><span class="line">        <span class="type">vec2_t</span> p = &#123;x, y&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> w0 = <span class="built_in">edge_cross</span>(&amp;v1, &amp;v2, &amp;p) + bias0;</span><br><span class="line">        <span class="type">int</span> w1 = <span class="built_in">edge_cross</span>(&amp;v2, &amp;v0, &amp;p) + bias1;</span><br><span class="line">        <span class="type">int</span> w2 = <span class="built_in">edge_cross</span>(&amp;v0, &amp;v1, &amp;p) + bias2;</span><br><span class="line">        </span><br><span class="line">        <span class="type">bool</span> is_inside = w0 &gt;= <span class="number">0</span> &amp;&amp; w1 &gt;= <span class="number">0</span> &amp;&amp; w2 &gt;= <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (is_inside) &#123;</span><br><span class="line">            <span class="built_in">draw_pixel</span>(x, y, color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Interpolate-Values-between-vertices"><a href="#Interpolate-Values-between-vertices" class="headerlink" title="Interpolate Values between vertices"></a>Interpolate Values between vertices</h2><h3 id="Barycentric-coordinate"><a href="#Barycentric-coordinate" class="headerlink" title="Barycentric coordinate"></a>Barycentric coordinate</h3><p>Represent where point P is inside the triangle.</p>
<div align="center">
  <img src="/images/SoftRender/baryCentricCoordinate.png" alt="Game Screenshot">
  <p>Barycentric coordinate</p>
</div>

<p>P comes from the alpha weight multiplied by the v0 plus beta weight multiplied by the v1 plus gamma weight multiplied by v2.<br>How to calculate the alpha, beta, gamma?<br>The magnitude of the cross product as the area of the parallelogram that is formed between A and B. SO Use cross product to get the area. Triangle Area divided by the area of the entire triangle. The area of Alpha is the w0 we had before(when determine if the point inside the triangle)</p>
<p>Now that w0, w1, w2 were our barycentric weights all along<br>They were the simple the barycentric weight scaled by the area of the parallelogram(2x the area of the triangle)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> bias0 = <span class="built_in">is_top_left</span>(&amp;v1, &amp;v2) ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> bias1 = <span class="built_in">is_top_left</span>(&amp;v2, &amp;v0) ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> bias2 = <span class="built_in">is_top_left</span>(&amp;v0, &amp;v1) ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> area = <span class="built_in">edge_cross</span>(&amp;v0, &amp;v1, &amp;v2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> y = y_min; y &lt;= y_max; y++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x = x_min; x &lt;= x_max; x++) &#123;</span><br><span class="line">        <span class="type">vec2_t</span> p = &#123;x, y&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> w0 = <span class="built_in">edge_cross</span>(&amp;v1, &amp;v2, &amp;p) + bias0;</span><br><span class="line">        <span class="type">int</span> w1 = <span class="built_in">edge_cross</span>(&amp;v2, &amp;v0, &amp;p) + bias1;</span><br><span class="line">        <span class="type">int</span> w2 = <span class="built_in">edge_cross</span>(&amp;v0, &amp;v1, &amp;p) + bias2;</span><br><span class="line">        </span><br><span class="line">        <span class="type">bool</span> is_inside = w0 &gt;= <span class="number">0</span> &amp;&amp; w1 &gt;= <span class="number">0</span> &amp;&amp; w2 &gt;= <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (is_inside) &#123;</span><br><span class="line">            <span class="type">float</span> alpha = w0 / (<span class="type">float</span>)area;</span><br><span class="line">            <span class="type">float</span> beta  = w1 / (<span class="type">float</span>)area;</span><br><span class="line">            <span class="type">float</span> gamma = w2 / (<span class="type">float</span>)area;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> a = <span class="number">0xFF</span>;</span><br><span class="line">            <span class="type">int</span> r = (alpha) * colors[<span class="number">0</span>].r + (beta) * colors[<span class="number">1</span>].r + (gamma) * colors[<span class="number">2</span>].r;</span><br><span class="line">            <span class="type">int</span> g = (alpha) * colors[<span class="number">0</span>].g + (beta) * colors[<span class="number">1</span>].g + (gamma) * colors[<span class="number">2</span>].g;</span><br><span class="line">            <span class="type">int</span> b = (alpha) * colors[<span class="number">0</span>].b + (beta) * colors[<span class="number">1</span>].b + (gamma) * colors[<span class="number">2</span>].b;</span><br><span class="line">            </span><br><span class="line">            <span class="type">uint32_t</span> interp_color = <span class="number">0x00000000</span>;</span><br><span class="line">            interp_color = (interp_color | a) &lt;&lt; <span class="number">8</span>;</span><br><span class="line">            interp_color = (interp_color | b) &lt;&lt; <span class="number">8</span>;</span><br><span class="line">            interp_color = (interp_color | g) &lt;&lt; <span class="number">8</span>;</span><br><span class="line">            interp_color = (interp_color | r);</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">draw_pixel</span>(x, y, interp_color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Constant-Increment"><a href="#Constant-Increment" class="headerlink" title="Constant Increment"></a>Constant Increment</h3><p>Barycentric coordinates are constant along lines parallel to an edge </p>
<div align="center">
  <img src="/images/SoftRender/BaryCentricCOnstant.png" alt="Game Screenshot">
</div>

<p>If our triangle edges are straight lines, and we are navigating the raster in straight lines, our <strong>difference</strong> of cross product is <strong>constant</strong> both horizontally and vertically.<br>We do not need to compute the edge function that edge cross per pixel. We just need to find the difference (delta) of w in x-axis and y-axis. And then increment by the delta</p>
<div align="center">
  <img src="/images/SoftRender/deltaW.png" alt="Game Screenshot">
  <p>Barycentric coordinate equation with px & py, we can find the increment</p>
</div>

<p>We can find our Delta W in X &amp; Y, for edge v0v1, and other edge is similar.<br>So the Delta W in the column domain, and the Delta W in the row domain, per scan line is going to be always the first vertex y minus the second vertex y. And the difference of w in the row domain is going to be the second vertex x minus the first vertex x.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x_min = <span class="built_in">min</span>(v<span class="number">0.</span>x, v<span class="number">1.</span>x, v<span class="number">2.</span>x);</span><br><span class="line"><span class="type">int</span> y_min = <span class="built_in">min</span>(v<span class="number">0.</span>y, v<span class="number">1.</span>y, v<span class="number">2.</span>y);</span><br><span class="line"><span class="type">int</span> x_max = <span class="built_in">max</span>(v<span class="number">0.</span>x, v<span class="number">1.</span>x, v<span class="number">2.</span>x);</span><br><span class="line"><span class="type">int</span> y_max = <span class="built_in">max</span>(v<span class="number">0.</span>y, v<span class="number">1.</span>y, v<span class="number">2.</span>y);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compute the constant delta_s that will be used for the horizontal and vertical steps</span></span><br><span class="line"><span class="type">int</span> delta_w0_col = (v<span class="number">1.</span>y - v<span class="number">2.</span>y); </span><br><span class="line"><span class="type">int</span> delta_w1_col = (v<span class="number">2.</span>y - v<span class="number">0.</span>y); </span><br><span class="line"><span class="type">int</span> delta_w2_col = (v<span class="number">0.</span>y - v<span class="number">1.</span>y); </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> delta_w0_col = (v<span class="number">2.</span>y - v<span class="number">1.</span>y); </span><br><span class="line"><span class="type">int</span> delta_w1_col = (v<span class="number">0.</span>y - v<span class="number">2.</span>y); </span><br><span class="line"><span class="type">int</span> delta_w2_col = (v<span class="number">1.</span>y - v<span class="number">0.</span>y); </span><br><span class="line"></span><br><span class="line"><span class="comment">// Compute the area of the entire triangle/parallelogram</span></span><br><span class="line"><span class="type">float</span> area = <span class="built_in">edge_cross</span>(&amp;v0, &amp;v1, &amp;v2);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> bias0 = <span class="built_in">is_top_left</span>(&amp;v1, &amp;v2) ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> bias1 = <span class="built_in">is_top_left</span>(&amp;v2, &amp;v0) ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> bias2 = <span class="built_in">is_top_left</span>(&amp;v0, &amp;v1) ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">vec2_t</span> p0 = &#123; x_min, y_min &#125;;</span><br><span class="line"><span class="type">int</span> w0_row = <span class="built_in">edge_cross</span>(&amp;v1, &amp;v2, &amp;p0) + bias0;</span><br><span class="line"><span class="type">int</span> w1_row = <span class="built_in">edge_cross</span>(&amp;v2, &amp;v0, &amp;p0) + bias1;</span><br><span class="line"><span class="type">int</span> w2_row = <span class="built_in">edge_cross</span>(&amp;v0, &amp;v1, &amp;p0) + bias2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> y = y_min; y &lt;= y_max; y++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> w0 = w0_row;</span><br><span class="line">    <span class="type">float</span> w1 = w1_row;</span><br><span class="line">    <span class="type">float</span> w2 = w2_row;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x = x_min; x &lt;= x_max; x++) &#123; </span><br><span class="line">        <span class="type">bool</span> is_inside = w0 &gt;= <span class="number">0</span> &amp;&amp; w1 &gt;= <span class="number">0</span> &amp;&amp; w2 &gt;= <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (is_inside) &#123;</span><br><span class="line">            <span class="type">float</span> alpha = w0 / (<span class="type">float</span>)area;</span><br><span class="line">            <span class="type">float</span> beta  = w1 / (<span class="type">float</span>)area;</span><br><span class="line">            <span class="type">float</span> gamma = w2 / (<span class="type">float</span>)area;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> a = <span class="number">0xFF</span>;</span><br><span class="line">            <span class="type">int</span> r = (alpha) * colors[<span class="number">0</span>].r + (beta) * colors[<span class="number">1</span>].r + (gamma) * colors[<span class="number">2</span>].r;</span><br><span class="line">            <span class="type">int</span> g = (alpha) * colors[<span class="number">0</span>].g + (beta) * colors[<span class="number">1</span>].g + (gamma) * colors[<span class="number">2</span>].g;</span><br><span class="line">            <span class="type">int</span> b = (alpha) * colors[<span class="number">0</span>].b + (beta) * colors[<span class="number">1</span>].b + (gamma) * colors[<span class="number">2</span>].b;</span><br><span class="line">            </span><br><span class="line">            <span class="type">uint32_t</span> interp_color = <span class="number">0x00000000</span>;</span><br><span class="line">            interp_color = (interp_color | a) &lt;&lt; <span class="number">8</span>;</span><br><span class="line">            interp_color = (interp_color | b) &lt;&lt; <span class="number">8</span>;</span><br><span class="line">            interp_color = (interp_color | g) &lt;&lt; <span class="number">8</span>;</span><br><span class="line">            interp_color = (interp_color | r);</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">draw_pixel</span>(x, y, interp_color);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        wo += delta_w0_col;</span><br><span class="line">        w1 += delta_w1_col;</span><br><span class="line">        w2 += delta_w2_col;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    wo_row += delta_w0_row;</span><br><span class="line">    w1_row += delta_w1_row;</span><br><span class="line">    w2_row += delta_w2_row;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Subpixel-precision"><a href="#Subpixel-precision" class="headerlink" title="Subpixel precision"></a>Subpixel precision</h2><p>If you don’t have Subpixel movement, if you don’t consider these values inside the pixel, this floating point, the fractional part of numbers, everything is going to Jitter a little bit<br>In our current implementation, we are only using integer data. We are always rounding things to the closest integer values.<br>Instead of using integer values we change everything to use floating point numbers. As the vertex is moving inside the pixel, subpixel movement everything changes right the way we are rendering the line.</p>
<p>cross return float now.</p>
<p>Push down for the minimum, Push up for maximum, vertex position now float.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x_min = <span class="built_in">floor</span>(<span class="built_in">min</span>(v<span class="number">0.</span>x, v<span class="number">1.</span>x, v<span class="number">2.</span>x));</span><br><span class="line"><span class="type">int</span> y_min = <span class="built_in">floor</span>(<span class="built_in">min</span>(v<span class="number">0.</span>y, v<span class="number">1.</span>y, v<span class="number">2.</span>y));</span><br><span class="line"><span class="type">int</span> x_max = <span class="built_in">ceil</span>(<span class="built_in">max</span>(v<span class="number">0.</span>x, v<span class="number">1.</span>x, v<span class="number">2.</span>x));</span><br><span class="line"><span class="type">int</span> y_max = <span class="built_in">ceil</span>(<span class="built_in">max</span>(v<span class="number">0.</span>y, v<span class="number">1.</span>y, v<span class="number">2.</span>y));</span><br></pre></td></tr></table></figure></p>
<p>the delta of w and w need to be float numbers</p>
<p>Most programmer do:<br>Whenever we are comparing is pixel belong to edge, we are taking the cross product the edge function between a pixel and a edge, instead of using the top left of the pixel, we should use the center of that pixel (add 0.5 bias).<br>The point that gets tested against the edge (via cross product) is the middle of the pixel.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec2_t</span> p0 = &#123; x_min + <span class="number">0.5</span>, y_min + <span class="number">0.5</span> &#125;;</span><br></pre></td></tr></table></figure></p>
<p>Problem: Some miss draw between left and right triangle, need to change the number of bias<br>(需要找到一个数作为bias，刚好把最右边边上面的像素的w减成小于0， 不影响右边稍微往左的像素，如果选择的w大了的话，影响的像素变多了不止最右边，太小了的话最右边的没减够，w还是大于零，还算在三角形里面)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> bias0 = <span class="built_in">is_top_left</span>(&amp;v1, &amp;v2) ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line"><span class="type">float</span> bias1 = <span class="built_in">is_top_left</span>(&amp;v2, &amp;v0) ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line"><span class="type">float</span> bias2 = <span class="built_in">is_top_left</span>(&amp;v0, &amp;v1) ? <span class="number">0</span> : <span class="number">-1</span>;</span><br></pre></td></tr></table></figure></p>
<p>Since we are not using integer values, what is the smallest floating point value that you have to push to pixels of the edge (bias)<br>Floats are discrete but not euqidistant. They have different resolutions depending on the value itself, so it is hard to say the bias.<br>One solution is use fixed point numbers, because fixed point numbers they use a constant number of bits to represent the integer part of a number and a constant number of bits to represent the decimal fractional part of number.<br>For example, you could use two 8-bits numbers, 8 bits for integer part and 8 bits for fractional part, to represent this fraction values. So you have 16 bits, you break them into eight and eight. But knowing that we have only 8 eight beats for the fractional part, gives us this consistency, we know what is the resolution that we can represent. The smallest value that we can represent using those eight bits. ALso works in other bits, like 32 bits</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://zhangzs11.github.io">Zishuai Zhang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://zhangzs11.github.io/2022/10/15/SoftRender-TriangleRasterizationPro/">https://zhangzs11.github.io/2022/10/15/SoftRender-TriangleRasterizationPro/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/MyAvatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2022/11/12/CPP-VirtualDestructors/" title="CPP-Virtual Destructors"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">CPP-Virtual Destructors</div></div><div class="info-2"><div class="info-item-1">Virtual DestructorsIf we have a base class pointer that is pointing to a drive class object instance on the heap, unless we have create the base class destructor using the virtual keyword, we’re at risk of having a memory leak occur when we delete the object Base Class1234567891011121314151617class BaseData&#123;public:    int *data        BaseData(int size)    &#123;        data = new int[size];    &#125;        ~BaseData()    &#123;        cout &lt;&lt; &quot;BaseData destructor is...</div></div></div></a><a class="pagination-related" href="/2022/08/10/SoftRender--Triangle%20Rasterization/" title="Software Rasterizer - Triangle Rasterization"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">Software Rasterizer - Triangle Rasterization</div></div><div class="info-2"><div class="info-item-1">Introduction to RasterizationRasterization is a critical step in the rendering pipeline, where transformed and clipped 3D triangles are converted into 2D pixels on the screen. This process determines which pixels are covered by each triangle and computes the necessary data for rendering them accurately. Here is the break down the steps leading up to rasterization and what happens during this process: Vertex ProcessingVertex Shader Transformation: Vertex positions, initially defined in object...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/MyAvatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Zishuai Zhang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">38</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/zhangzs11" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:zhangzs2023@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Introduction"><span class="toc-number">1.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Scanline-rasterizer"><span class="toc-number">2.</span> <span class="toc-text">Scanline rasterizer</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Another-rasterizer-which-is-appropriate-for-GPU"><span class="toc-number">3.</span> <span class="toc-text">Another rasterizer which is appropriate for GPU</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#High-level-overview"><span class="toc-number">3.1.</span> <span class="toc-text">High-level overview</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Important-Primitives"><span class="toc-number">3.1.1.</span> <span class="toc-text">Important Primitives</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Find-a-bounding-box-with-all-the-candidate-pixels"><span class="toc-number">3.1.2.</span> <span class="toc-text">Find a bounding box with all the candidate pixels</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Loop-all-candidate-pixels-in-the-bounding-box"><span class="toc-number">3.1.3.</span> <span class="toc-text">Loop all candidate pixels in the bounding box</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#How-to-determine-if-a-point-is-inside-or-outside-a-triangle"><span class="toc-number">3.2.</span> <span class="toc-text">How to determine if a point is inside or outside a triangle</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3D-vector-CROSS-product"><span class="toc-number">3.2.1.</span> <span class="toc-text">3D vector CROSS product</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2D-vector-Cross-product"><span class="toc-number">3.2.2.</span> <span class="toc-text">2D vector Cross product</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fill-Convention-Rule-Top-Left-rule"><span class="toc-number">3.3.</span> <span class="toc-text">Fill Convention Rule (Top-Left rule)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#How-do-I-know-if-a-edge-is-a-flat-top-edge-or-left-edge"><span class="toc-number">3.3.1.</span> <span class="toc-text">How do I know if a edge is a flat top edge or left edge?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Interpolate-Values-between-vertices"><span class="toc-number">3.4.</span> <span class="toc-text">Interpolate Values between vertices</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Barycentric-coordinate"><span class="toc-number">3.4.1.</span> <span class="toc-text">Barycentric coordinate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Constant-Increment"><span class="toc-number">3.4.2.</span> <span class="toc-text">Constant Increment</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Subpixel-precision"><span class="toc-number">3.5.</span> <span class="toc-text">Subpixel precision</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/20/GraphicsSystem-DeferredRendering/" title="GraphicsSystem-Deferred Rendering">GraphicsSystem-Deferred Rendering</a><time datetime="2025-01-20T21:05:08.640Z" title="Created 2025-01-20 14:05:08">2025-01-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/18/GraphicsSystem-FXAA/" title="GraphicsSystem-FXAA">GraphicsSystem-FXAA</a><time datetime="2025-01-19T05:19:14.585Z" title="Created 2025-01-18 22:19:14">2025-01-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/18/GraphicsSystem-NormalMapping/" title="GraphicsSystem-Normal Mapping">GraphicsSystem-Normal Mapping</a><time datetime="2025-01-18T18:19:54.862Z" title="Created 2025-01-18 11:19:54">2025-01-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/18/GraphicsSystem-Skybox/" title="GraphicsSystem-Skybox">GraphicsSystem-Skybox</a><time datetime="2025-01-18T18:19:22.199Z" title="Created 2025-01-18 11:19:22">2025-01-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/16/Graphics_System-Shadow/" title="GraphicsSystem-Shadow Mapping">GraphicsSystem-Shadow Mapping</a><time datetime="2024-12-16T07:00:00.000Z" title="Created 2024-12-16 00:00:00">2024-12-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Zishuai Zhang</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>