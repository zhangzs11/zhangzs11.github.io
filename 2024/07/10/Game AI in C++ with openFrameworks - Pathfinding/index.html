<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Game AI in C++ with openFrameworks - Pathfinding | Canned Pixels</title><meta name="author" content="Zishuai Zhang,zhangzs2023@163.com"><meta name="copyright" content="Zishuai Zhang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Pathfinding AlgorithmsPathfinding algorithms are essential for navigating game environments, and the key differences between these algorithms lies in how they prioritize which nodes to explore first.">
<meta property="og:type" content="article">
<meta property="og:title" content="Game AI in C++ with openFrameworks - Pathfinding">
<meta property="og:url" content="https://zhangzs11.github.io/2024/07/10/Game%20AI%20in%20C++%20with%20openFrameworks%20-%20Pathfinding/index.html">
<meta property="og:site_name" content="Canned Pixels">
<meta property="og:description" content="Pathfinding AlgorithmsPathfinding algorithms are essential for navigating game environments, and the key differences between these algorithms lies in how they prioritize which nodes to explore first.">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://zhangzs11.github.io/img/MyAvatar.jpg">
<meta property="article:published_time" content="2024-07-10T06:00:00.000Z">
<meta property="article:modified_time" content="2024-12-16T09:48:40.270Z">
<meta property="article:author" content="Zishuai Zhang">
<meta property="article:tag" content="Computer Graphics, D3D, Game Engine Development">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhangzs11.github.io/img/MyAvatar.jpg"><link rel="shortcut icon" href="/img/MyAvatar.jpg"><link rel="canonical" href="https://zhangzs11.github.io/2024/07/10/Game%20AI%20in%20C++%20with%20openFrameworks%20-%20Pathfinding/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Game AI in C++ with openFrameworks - Pathfinding',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background: linear-gradient(20deg, #b9fbc0, #98f5e1, #90dbf4, #cfbaf0);"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/Funny/doc_room_pixel.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Canned Pixels</span></a><a class="nav-page-title" href="/"><span class="site-name">Game AI in C++ with openFrameworks - Pathfinding</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Game AI in C++ with openFrameworks - Pathfinding<a class="post-edit-link" href="null_posts/Game AI in C++ with openFrameworks - Pathfinding.md" title="Edit" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-07-10T06:00:00.000Z" title="Created 2024-07-10 00:00:00">2024-07-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-12-16T09:48:40.270Z" title="Updated 2024-12-16 02:48:40">2024-12-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Game-AI/">Game AI</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Pathfinding-Algorithms"><a href="#Pathfinding-Algorithms" class="headerlink" title="Pathfinding Algorithms"></a>Pathfinding Algorithms</h1><p>Pathfinding algorithms are essential for navigating game environments, and the key <strong>differences</strong> between these algorithms lies in <strong>how they prioritize which nodes to explore first</strong>. This prioritization is typically managed through <strong>a frontier set or queue</strong>, <strong>where nodes are sorted based on different criteria</strong>.</p>
<h2 id="Dijkstra’s-Algorithm"><a href="#Dijkstra’s-Algorithm" class="headerlink" title="Dijkstra’s Algorithm"></a>Dijkstra’s Algorithm</h2><h3 id="Prioritization"><a href="#Prioritization" class="headerlink" title="Prioritization:"></a>Prioritization:</h3><p>Dijkstra’s Algorithm prioritizes nodes solely based on the cost <strong>from the start node to the current node (g(n))</strong>. It expands nodes with <strong>the lowest total cost g(n)</strong> and <strong>doesn’t use any heuristic estimate</strong> to guide the search toward the goal.</p>
<h3 id="Behavior"><a href="#Behavior" class="headerlink" title="Behavior:"></a>Behavior:</h3><p>Dijkstra is <strong>guaranteed to find the shortest path</strong>, but it can be inefficient because it <strong>explores many unnecessary nodes</strong>, even those far from the goal.</p>
<h3 id="code"><a href="#code" class="headerlink" title="code:"></a>code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">std::pair&lt;std::unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, std::unordered_map&lt;<span class="type">int</span>, <span class="type">float</span>&gt;&gt; <span class="built_in">dijkstra</span>(<span class="type">int</span> start, <span class="type">int</span> goal) <span class="type">const</span> &#123;</span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; came_from;</span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, <span class="type">float</span>&gt; cost_so_far;</span><br><span class="line">    std::set&lt;std::pair&lt;<span class="type">float</span>, <span class="type">int</span>&gt;&gt; frontier;</span><br><span class="line"></span><br><span class="line">    came_from[start] = <span class="number">-1</span>;</span><br><span class="line">    cost_so_far[start] = <span class="number">0</span>;</span><br><span class="line">    frontier.<span class="built_in">insert</span>(&#123; <span class="number">0</span>, start &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!frontier.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> current = frontier.<span class="built_in">begin</span>()-&gt;second;</span><br><span class="line">        frontier.<span class="built_in">erase</span>(frontier.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (current == goal) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; edge : <span class="built_in">getOutgoingEdges</span>(current)) &#123;</span><br><span class="line">            <span class="type">int</span> next = edge.<span class="built_in">getSink</span>();</span><br><span class="line">            <span class="type">float</span> new_cost = cost_so_far[current] + <span class="built_in">getCost</span>(current, next);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!cost_so_far.<span class="built_in">count</span>(next) || new_cost &lt; cost_so_far[next]) &#123;</span><br><span class="line">                cost_so_far[next] = new_cost;</span><br><span class="line">                <span class="type">float</span> priority = new_cost;</span><br><span class="line">                frontier.<span class="built_in">erase</span>(&#123; cost_so_far[next], next &#125;);</span><br><span class="line">                frontier.<span class="built_in">insert</span>(&#123; priority, next &#125;);</span><br><span class="line">                came_from[next] = current;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; came_from, cost_so_far &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Greedy-Best-First-Search"><a href="#Greedy-Best-First-Search" class="headerlink" title="Greedy Best-First Search"></a>Greedy Best-First Search</h2><h3 id="Prioritization-1"><a href="#Prioritization-1" class="headerlink" title="Prioritization:"></a>Prioritization:</h3><p>This algorithm prioritizes nodes based <strong>purely on the estimated cost from the current node to the goal (h(n))</strong>. It doesn’t take into account the actual cost from the start node.</p>
<h3 id="Behavior-1"><a href="#Behavior-1" class="headerlink" title="Behavior:"></a>Behavior:</h3><p>Greedy search is fast because it aggressively moves towards the goal, but it <strong>ignores the actual cost</strong> to reach each node. This can lead to <strong>suboptimal paths or even failure</strong> to find a valid path in some cases.</p>
<h2 id="A-Algorithm"><a href="#A-Algorithm" class="headerlink" title="A* Algorithm"></a>A* Algorithm</h2><h3 id="Prioritization-2"><a href="#Prioritization-2" class="headerlink" title="Prioritization:"></a>Prioritization:</h3><p>A<em> combines both <strong>actual cost g(n)</strong> (from the start node to the current node) <em>*and the heuristic h(n)</em></em> (estimated cost from the current node to the goal) into a single evaluation function:</p>
<script type="math/tex; mode=display">
f(n)=g(n)+h(n)</script><p>A* balances the search between finding a low-cost path and quickly reaching the goal.</p>
<h3 id="Behavior-2"><a href="#Behavior-2" class="headerlink" title="Behavior:"></a>Behavior:</h3><p>If the heuristic h(n) is admissible (i.e., <strong>it never overestimates the actual cost to the goal</strong>), A<em> is <strong>guaranteed to find the optimal path</strong>. By guiding the search with a heuristic, A</em> tends to explore <strong>fewer unnecessary nodes than Dijkstra</strong>, making it more efficient.</p>
<h3 id="code-1"><a href="#code-1" class="headerlink" title="code:"></a>code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Heuristics </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">float</span> <span class="title">manhattanDistance</span><span class="params">(<span class="type">int</span> current, <span class="type">int</span> goal, <span class="type">const</span> std::unordered_map&lt;<span class="type">int</span>, Node&gt;&amp; vertices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; currentVertex = vertices.<span class="built_in">at</span>(current);</span><br><span class="line">    <span class="keyword">auto</span>&amp; goalVertex = vertices.<span class="built_in">at</span>(goal);</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">abs</span>(currentVertex.position.x * <span class="built_in">ofGetWidth</span>() - goalVertex.position.x * <span class="built_in">ofGetWidth</span>()) + std::<span class="built_in">abs</span>(currentVertex.position.y * <span class="built_in">ofGetHeight</span>() - goalVertex.position.y * <span class="built_in">ofGetHeight</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">float</span> <span class="title">euclideanDistance</span><span class="params">(<span class="type">int</span> current, <span class="type">int</span> goal, <span class="type">const</span> std::unordered_map&lt;<span class="type">int</span>, Node&gt;&amp; vertices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; currentVertex = vertices.<span class="built_in">at</span>(current);</span><br><span class="line">    <span class="keyword">auto</span>&amp; goalVertex = vertices.<span class="built_in">at</span>(goal);</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">sqrt</span>(std::<span class="built_in">pow</span>(currentVertex.position.x * <span class="built_in">ofGetWidth</span>() - goalVertex.position.x * <span class="built_in">ofGetWidth</span>(), <span class="number">2</span>) + std::<span class="built_in">pow</span>(currentVertex.position.y * <span class="built_in">ofGetHeight</span>() - goalVertex.position.y * <span class="built_in">ofGetHeight</span>(), <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A*</span></span><br><span class="line">std::pair&lt;std::unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, std::unordered_map&lt;<span class="type">int</span>, <span class="type">float</span>&gt;&gt; <span class="built_in">aStar</span>(<span class="type">int</span> start, <span class="type">int</span> goal, std::function&lt;<span class="built_in">float</span>(<span class="type">int</span>, <span class="type">int</span>, <span class="type">const</span> std::unordered_map&lt;<span class="type">int</span>, Node&gt;&amp;)&gt; heuristic) <span class="type">const</span> &#123;</span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; came_from;</span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, <span class="type">float</span>&gt; cost_so_far;</span><br><span class="line">    std::set&lt;std::pair&lt;<span class="type">float</span>, <span class="type">int</span>&gt;&gt; frontier;</span><br><span class="line"></span><br><span class="line">    came_from[start] = <span class="number">-1</span>;</span><br><span class="line">    cost_so_far[start] = <span class="number">0</span>;</span><br><span class="line">    frontier.<span class="built_in">insert</span>(&#123; <span class="number">0</span>, start &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!frontier.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> current = frontier.<span class="built_in">begin</span>()-&gt;second;</span><br><span class="line">        frontier.<span class="built_in">erase</span>(frontier.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (current == goal) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; edge : <span class="built_in">getOutgoingEdges</span>(current)) &#123;</span><br><span class="line">            <span class="type">int</span> next = edge.<span class="built_in">getSink</span>();</span><br><span class="line">            <span class="type">float</span> new_cost = cost_so_far[current] + <span class="built_in">getCost</span>(current, next);</span><br><span class="line">            <span class="type">float</span> priority = new_cost + <span class="built_in">heuristic</span>(next, goal, vertices);   <span class="comment">// Different with the Dijkstra’s</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!cost_so_far.<span class="built_in">count</span>(next) || new_cost &lt; cost_so_far[next]) &#123;</span><br><span class="line">                cost_so_far[next] = new_cost;</span><br><span class="line">                frontier.<span class="built_in">erase</span>(&#123; cost_so_far[next] + <span class="built_in">heuristic</span>(next, goal, vertices), next &#125;);</span><br><span class="line">                frontier.<span class="built_in">insert</span>(&#123; priority, next &#125;);</span><br><span class="line">                came_from[next] = current;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; came_from, cost_so_far &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="The-Role-of-the-Heuristic-in-A"><a href="#The-Role-of-the-Heuristic-in-A" class="headerlink" title="The Role of the Heuristic in A*:"></a>The Role of the Heuristic in A*:</h2><ul>
<li><strong>If the heuristic is 0:</strong> A<em> degenerates into Dijkstra’s Algorithm because it no longer considers the goal and only uses the actual cost g(n) to expand nodes. This means A</em> will find the shortest path, but without the benefit of the heuristic, it will explore more nodes, same with Dijkstra’s behavior.</li>
<li><strong>If the heuristic is too large:</strong> A<em> behaves more like Greedy Best-First Search, where it aggressively pursues the goal, potentially sacrificing the shortest path for speed. A too-large heuristic can lead A</em> to miss the optimal path.</li>
<li><strong>When the heuristic is admissible:</strong> If the heuristic is an underestimate of the true cost to the goal, A* can find the shortest path while also reducing the search space, making it more efficient than Dijkstra.</li>
</ul>
<h1 id="Graph-Node-Generation-Based-on-Obstacles-in-Map"><a href="#Graph-Node-Generation-Based-on-Obstacles-in-Map" class="headerlink" title="Graph Node Generation Based on Obstacles in Map"></a>Graph Node Generation Based on Obstacles in Map</h1><p>Nodes can be generated at <strong>regular intervals across the map to form a grid</strong>. However, this approach often results in an <strong>unnecessarily large number of nodes</strong>, many of which do not contribute to the efficiency of the pathfinding process. My approach to node generation uses a <strong>recursive algorithm that strategically places nodes</strong> in open areas, avoiding obstacles, and creates <strong>fewer nodes while still ensuring the entire map remains navigable</strong>.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">generateNodesRecursively</span><span class="params">(<span class="type">const</span> ofRectangle&amp; region, <span class="type">int</span> maxDepth, <span class="type">float</span> minSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Base case: if the recursion depth limit is reached or the region size is too small</span></span><br><span class="line">    <span class="keyword">if</span> (maxDepth &lt;= <span class="number">0</span> || region.<span class="built_in">getWidth</span>() * <span class="built_in">ofGetWidth</span>() &lt;= minSize || region.<span class="built_in">getHeight</span>() * <span class="built_in">ofGetHeight</span>() &lt;= minSize) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check the relationship between the region and obstacles</span></span><br><span class="line">    <span class="type">bool</span> hasCollision = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> fullyCovered = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; polygon : collisionList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isRegionInsidePolygon</span>(region, polygon)) &#123;</span><br><span class="line">            <span class="comment">// The region is completely covered by an obstacle</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">doesRegionIntersectPolygon</span>(region, polygon)) &#123;</span><br><span class="line">            hasCollision = <span class="literal">true</span>;  <span class="comment">// The region intersects or partially overlaps with an obstacle</span></span><br><span class="line">            fullyCovered = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there are no obstacles, generate a node at the center of the region</span></span><br><span class="line">    <span class="keyword">if</span> (!hasCollision) &#123;</span><br><span class="line">        ofVec2f center = region.<span class="built_in">getCenter</span>();</span><br><span class="line">        <span class="type">int</span> newId = graph-&gt;vertices.<span class="built_in">size</span>();</span><br><span class="line">        graph-&gt;<span class="built_in">addVertex</span>(newId, center.x, center.y);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Connect the new node to existing nodes</span></span><br><span class="line">        <span class="built_in">connectToExistingNodes</span>(newId);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the region is partially covered by obstacles, subdivide the region further</span></span><br><span class="line">    <span class="type">float</span> halfWidth = region.<span class="built_in">getWidth</span>() / <span class="number">2.0f</span>;</span><br><span class="line">    <span class="type">float</span> halfHeight = region.<span class="built_in">getHeight</span>() / <span class="number">2.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recursively process the four subregions</span></span><br><span class="line">    <span class="built_in">generateNodesRecursively</span>(<span class="built_in">ofRectangle</span>(region.<span class="built_in">getX</span>(), region.<span class="built_in">getY</span>(), halfWidth, halfHeight), maxDepth - <span class="number">1</span>, minSize);</span><br><span class="line">    <span class="built_in">generateNodesRecursively</span>(<span class="built_in">ofRectangle</span>(region.<span class="built_in">getX</span>() + halfWidth, region.<span class="built_in">getY</span>(), halfWidth, halfHeight), maxDepth - <span class="number">1</span>, minSize);</span><br><span class="line">    <span class="built_in">generateNodesRecursively</span>(<span class="built_in">ofRectangle</span>(region.<span class="built_in">getX</span>(), region.<span class="built_in">getY</span>() + halfHeight, halfWidth, halfHeight), maxDepth - <span class="number">1</span>, minSize);</span><br><span class="line">    <span class="built_in">generateNodesRecursively</span>(<span class="built_in">ofRectangle</span>(region.<span class="built_in">getX</span>() + halfWidth, region.<span class="built_in">getY</span>() + halfHeight, halfWidth, halfHeight), maxDepth - <span class="number">1</span>, minSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">connectToExistingNodes</span><span class="params">(<span class="type">int</span> newNodeId)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> ofVec2f&amp; newNodePosition = graph-&gt;vertices[newNodeId].position;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [id, node] : graph-&gt;vertices) &#123;</span><br><span class="line">        <span class="keyword">if</span> (id != newNodeId) &#123;</span><br><span class="line">            <span class="type">float</span> distance = newNodePosition.<span class="built_in">distance</span>(node.position);</span><br><span class="line">            <span class="type">bool</span> pathBlocked = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; polygon : collisionList) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">willCollide</span>(<span class="built_in">mapToScreenCoordinates</span>(newNodePosition), <span class="built_in">mapToScreenCoordinates</span>(node.position), polygon)) &#123;</span><br><span class="line">                    pathBlocked = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!pathBlocked) &#123;</span><br><span class="line">                <span class="type">float</span> weight = distance;</span><br><span class="line">                graph-&gt;<span class="built_in">addEdgeDouble</span>(newNodeId, id, weight);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div align="center">
  <img src="/images/GameAIDemo/nodeGenerate.png" alt="Game Screenshot">
  <p>Node Generation</p>
</div>

<h2 id="Benefits-of-Recursive-Node-Generation"><a href="#Benefits-of-Recursive-Node-Generation" class="headerlink" title="Benefits of Recursive Node Generation"></a>Benefits of Recursive Node Generation</h2><p><strong>1. Fewer Unnecessary Nodes:</strong></p>
<p>Instead of placing nodes uniformly across the map, this method strategically generates nodes only where they are needed. In open areas with no obstacles, fewer nodes are generated. Conversely, in regions with more obstacles, the algorithm subdivides the area further, placing nodes only where necessary to maintain connectivity. This reduces the overall number of nodes compared to uniform grids, especially in large open areas.</p>
<p><strong>2. Efficient Handling of Complex Maps:</strong></p>
<p>In complex maps with many obstacles, uniformly spaced nodes may fail to connect all regions without setting a very small node interval, which leads to an explosion in the number of nodes. With recursive subdivision, more nodes are added only in areas where connectivity is critical, meaning that fewer nodes are used overall while still ensuring the graph remains fully connected.</p>
<p><strong>3. Optimized Connectivity:</strong></p>
<p>The recursive approach ensures that regions with obstacles are handled more precisely, and nodes are placed in positions that maintain the graph’s connectivity without redundant nodes in open areas. This makes the method more efficient both in terms of memory and performance when running pathfinding algorithms like A*.</p>
<h1 id="Combine-Movement-with-the-Path-we-got"><a href="#Combine-Movement-with-the-Path-we-got" class="headerlink" title="Combine Movement with the Path we got"></a>Combine Movement with the Path we got</h1><div align="center">
  <img src="/images/GameAIDemo/pathMove.gif" alt="Game Screenshot">
  <p>Start Path Finding!</p>
</div>

<h2 id="Node-Navigation"><a href="#Node-Navigation" class="headerlink" title="Node Navigation:"></a>Node Navigation:</h2><ol>
<li>The character follows a precomputed path, moving <strong>from one node to the next</strong>.</li>
<li>If there is <strong><em>no collision between the character’s current position and the next node</em></strong>, the character <strong>skips</strong> moving to the current node and directly heads toward the next node. This makes movement more efficient.</li>
</ol>
<h2 id="Why-Use-Arrive-Instead-of-Seek"><a href="#Why-Use-Arrive-Instead-of-Seek" class="headerlink" title="Why Use Arrive Instead of Seek?"></a>Why Use Arrive Instead of Seek?</h2><p>In this case, I chose to use the <strong>Arrive behavior</strong> for movement rather than Seek to <strong>avoid overshooting and unnecessary detours</strong>. Here’s why:</p>
<h3 id="Seek-Behavior-in-Path-Finding"><a href="#Seek-Behavior-in-Path-Finding" class="headerlink" title="Seek Behavior in Path Finding:"></a>Seek Behavior in Path Finding:</h3><ol>
<li><p>Seek works by constantly moving toward the target at maximum speed, which can lead to <strong>overshooting</strong> the target. After passing the target, the character <strong>has to turn around and correct its position</strong>. This results in unnecessary detours and inefficient movement. I initially tried using larger acceleration values to reduce this issue, but the problem persisted.</p>
</li>
<li><p>Even with larger acceleration values, the acceleration’s direction is determined by <strong>the character’s position relative to the target</strong>. This means the character only <strong>starts decelerating after it has already passed the target</strong>. So, no matter how much I increased the acceleration, the character would still overshoot and then have to correct itself, leading to inefficient movement.</p>
</li>
<li><p><strong>Especially when changing directions</strong>. For example, if the character is currently moving along the x-axis and the next movement requires a turn toward the y-axis, overshooting can become more problematic. Since the target position only informs the character to <strong>accelerate along the y-axis</strong>, the character’s <strong>speed along the x-axis does not adjust properly</strong> until it has already moved too far in the x direction. This causes unnecessary detours along the x-axis, which is not the desired result.</p>
</li>
</ol>
<h3 id="Arrive-Behavior-in-Path-Finding"><a href="#Arrive-Behavior-in-Path-Finding" class="headerlink" title="Arrive Behavior in Path Finding:"></a>Arrive Behavior in Path Finding:</h3><p>Arrive solves this problem by gradually reducing the character’s speed as it approaches the target, ensuring smooth deceleration. The character can slow down before reaching the target, resulting in smoother, more accurate movements without overshooting. This controlled deceleration makes Arrive much more effective for precise movements and avoiding overshooting, especially in situations where the target may be close or surrounded by obstacles.</p>
<h2 id="code-2"><a href="#code-2" class="headerlink" title="code:"></a>code:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">updatePositionUsingGraph</span><span class="params">(<span class="type">float</span> deltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ofVec2f movingTarget;</span><br><span class="line">    playerPosition = character-&gt;position;</span><br><span class="line">    <span class="comment">// Check if currentNodeIndex and path range are valid</span></span><br><span class="line">    <span class="keyword">if</span> (currentNodeIndex &lt; path.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">        ofVec2f nextNodePosition = <span class="built_in">mapToScreenCoordinates</span>(map-&gt;graph-&gt;vertices[path[currentNodeIndex + <span class="number">1</span>]].<span class="built_in">getPosition</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check for collisions between the player and the next target node</span></span><br><span class="line">        <span class="type">bool</span> collisionDetected = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; polygon : map-&gt;collisionList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">willCollide</span>(playerPosition, nextNodePosition, polygon)) &#123;</span><br><span class="line">                collisionDetected = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!collisionDetected) &#123;</span><br><span class="line">            <span class="comment">// If no collision, move towards the next node</span></span><br><span class="line">            currentNodeIndex++;</span><br><span class="line">            nextNodeIndex++;</span><br><span class="line">            movingTarget = <span class="built_in">mapToScreenCoordinates</span>(map-&gt;graph-&gt;vertices[path[currentNodeIndex]].<span class="built_in">getPosition</span>());</span><br><span class="line">            arriveBehavior-&gt;<span class="built_in">setTargetPosition</span>(movingTarget);</span><br><span class="line">            arriveBehavior-&gt;<span class="built_in">updatePosition</span>(deltaTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (playerPosition.<span class="built_in">distance</span>(<span class="built_in">mapToScreenCoordinates</span>(map-&gt;graph-&gt;vertices[path[currentNodeIndex]].<span class="built_in">getPosition</span>())) &lt; <span class="number">20.0f</span>) &#123;</span><br><span class="line">            <span class="comment">// If there is a collision, but the player is near the current node, move to the next node</span></span><br><span class="line">            currentNodeIndex++;</span><br><span class="line">            nextNodeIndex++;</span><br><span class="line">            movingTarget = <span class="built_in">mapToScreenCoordinates</span>(map-&gt;graph-&gt;vertices[path[currentNodeIndex]].<span class="built_in">getPosition</span>());</span><br><span class="line">            arriveBehavior-&gt;<span class="built_in">setTargetPosition</span>(movingTarget);</span><br><span class="line">            arriveBehavior-&gt;<span class="built_in">updatePosition</span>(deltaTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// If there is a collision and the player has not reached the current node, move towards the current node</span></span><br><span class="line">            movingTarget = <span class="built_in">mapToScreenCoordinates</span>(map-&gt;graph-&gt;vertices[path[currentNodeIndex]].<span class="built_in">getPosition</span>());</span><br><span class="line">            arriveBehavior-&gt;<span class="built_in">setTargetPosition</span>(movingTarget);</span><br><span class="line">            arriveBehavior-&gt;<span class="built_in">updatePosition</span>(deltaTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (currentNodeIndex == path.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// Check for obstacles between the player and the final target, currently heading towards the last node</span></span><br><span class="line">        <span class="type">bool</span> collisionDetected = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; polygon : map-&gt;collisionList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">willCollide</span>(playerPosition, targetPosition, polygon)) &#123;</span><br><span class="line">                collisionDetected = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!collisionDetected) &#123;</span><br><span class="line">            <span class="comment">// If no obstacles, move directly towards the target</span></span><br><span class="line">            movingTarget = targetPosition;</span><br><span class="line">            arriveBehavior-&gt;<span class="built_in">setTargetPosition</span>(movingTarget);</span><br><span class="line">            arriveBehavior-&gt;<span class="built_in">updatePosition</span>(deltaTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (playerPosition.<span class="built_in">distance</span>(<span class="built_in">mapToScreenCoordinates</span>(map-&gt;graph-&gt;vertices[path[currentNodeIndex]].<span class="built_in">getPosition</span>())) &lt; <span class="number">0.02</span>) &#123;</span><br><span class="line">            <span class="comment">// If there are obstacles but the player has reached the current node, move towards the final target</span></span><br><span class="line">            currentNodeIndex = path.<span class="built_in">size</span>();</span><br><span class="line">            movingTarget = targetPosition;</span><br><span class="line">            arriveBehavior-&gt;<span class="built_in">setTargetPosition</span>(movingTarget);</span><br><span class="line">            arriveBehavior-&gt;<span class="built_in">updatePosition</span>(deltaTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// If obstacles are present, move towards the current last node</span></span><br><span class="line">            movingTarget = <span class="built_in">mapToScreenCoordinates</span>(map-&gt;graph-&gt;vertices[path[currentNodeIndex]].<span class="built_in">getPosition</span>());</span><br><span class="line">            arriveBehavior-&gt;<span class="built_in">setTargetPosition</span>(movingTarget);</span><br><span class="line">            arriveBehavior-&gt;<span class="built_in">updatePosition</span>(deltaTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://zhangzs11.github.io">Zishuai Zhang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://zhangzs11.github.io/2024/07/10/Game%20AI%20in%20C++%20with%20openFrameworks%20-%20Pathfinding/">https://zhangzs11.github.io/2024/07/10/Game%20AI%20in%20C++%20with%20openFrameworks%20-%20Pathfinding/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/MyAvatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/07/25/Game%20AI%20in%20C++%20with%20openFrameworks%20-%20Behaviour%20Tree/" title="Game AI in C++ with openFrameworks - Decision-Making Part (I) - Behaviour Tree"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">Game AI in C++ with openFrameworks - Decision-Making Part (I) - Behaviour Tree</div></div><div class="info-2"><div class="info-item-1">BehaviourTree ClassCode123456789101112131415class BehaviourTree &#123;private:    Task* root;    Blackboard* blackboard;    Tick* tick;public:    BehaviourTree(Task* root, Blackboard* blackboard, Tick* tick) : root(root), blackboard(blackboard), tick(tick) &#123;&#125;    Status makeDecision(float deltaTime) &#123;        Status result;        result = root-&gt;run(*tick);        tick-&gt;frameTime = deltaTime;        return result;    &#125;&#125;; Components1. Task root:This represents the...</div></div></div></a><a class="pagination-related" href="/2024/06/29/Game%20AI%20in%20C++%20with%20openFrameworks%20--%20Movement/" title="Game AI in C++ with openFrameworks - Movement"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">Game AI in C++ with openFrameworks - Movement</div></div><div class="info-2"><div class="info-item-1">Movement BasicsThe core principle behind movement in game AI is to compute a force that influences an entity’s velocity and position each frame. This force determines how the entity accelerates toward or away from a target. The basic process can be broken down into the following steps:  Compute Force: Calculate the force applied to the entity. Different movements have different way to calculate. Update Velocity: Add the force to the current velocity, influencing the entity’s speed and...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/MyAvatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Zishuai Zhang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">43</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/zhangzs11" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:zhangzs2023@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Pathfinding-Algorithms"><span class="toc-number">1.</span> <span class="toc-text">Pathfinding Algorithms</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Dijkstra%E2%80%99s-Algorithm"><span class="toc-number">1.1.</span> <span class="toc-text">Dijkstra’s Algorithm</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Prioritization"><span class="toc-number">1.1.1.</span> <span class="toc-text">Prioritization:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Behavior"><span class="toc-number">1.1.2.</span> <span class="toc-text">Behavior:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#code"><span class="toc-number">1.1.3.</span> <span class="toc-text">code:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Greedy-Best-First-Search"><span class="toc-number">1.2.</span> <span class="toc-text">Greedy Best-First Search</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Prioritization-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">Prioritization:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Behavior-1"><span class="toc-number">1.2.2.</span> <span class="toc-text">Behavior:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#A-Algorithm"><span class="toc-number">1.3.</span> <span class="toc-text">A* Algorithm</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Prioritization-2"><span class="toc-number">1.3.1.</span> <span class="toc-text">Prioritization:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Behavior-2"><span class="toc-number">1.3.2.</span> <span class="toc-text">Behavior:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#code-1"><span class="toc-number">1.3.3.</span> <span class="toc-text">code:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#The-Role-of-the-Heuristic-in-A"><span class="toc-number">1.4.</span> <span class="toc-text">The Role of the Heuristic in A*:</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Graph-Node-Generation-Based-on-Obstacles-in-Map"><span class="toc-number">2.</span> <span class="toc-text">Graph Node Generation Based on Obstacles in Map</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Benefits-of-Recursive-Node-Generation"><span class="toc-number">2.1.</span> <span class="toc-text">Benefits of Recursive Node Generation</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Combine-Movement-with-the-Path-we-got"><span class="toc-number">3.</span> <span class="toc-text">Combine Movement with the Path we got</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Node-Navigation"><span class="toc-number">3.1.</span> <span class="toc-text">Node Navigation:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Why-Use-Arrive-Instead-of-Seek"><span class="toc-number">3.2.</span> <span class="toc-text">Why Use Arrive Instead of Seek?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Seek-Behavior-in-Path-Finding"><span class="toc-number">3.2.1.</span> <span class="toc-text">Seek Behavior in Path Finding:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Arrive-Behavior-in-Path-Finding"><span class="toc-number">3.2.2.</span> <span class="toc-text">Arrive Behavior in Path Finding:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code-2"><span class="toc-number">3.3.</span> <span class="toc-text">code:</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/29/SoftRender-TriangleRasterizationPro/" title="Software Rasterizer - Triangle Rasterization Pro">Software Rasterizer - Triangle Rasterization Pro</a><time datetime="2025-01-29T18:17:31.961Z" title="Created 2025-01-29 11:17:31">2025-01-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/25/CG_PBR/" title="CG-Physically Based Rendering">CG-Physically Based Rendering</a><time datetime="2025-01-26T00:04:53.977Z" title="Created 2025-01-25 17:04:53">2025-01-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/25/CG_HowWriteFastShader/" title="CG-How to Write Fast Shaders">CG-How to Write Fast Shaders</a><time datetime="2025-01-25T20:04:44.068Z" title="Created 2025-01-25 13:04:44">2025-01-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/20/GraphicsSystem-DeferredRendering/" title="GraphicsSystem-Deferred Rendering">GraphicsSystem-Deferred Rendering</a><time datetime="2025-01-20T21:05:08.640Z" title="Created 2025-01-20 14:05:08">2025-01-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/18/GraphicsSystem-FXAA/" title="GraphicsSystem-FXAA">GraphicsSystem-FXAA</a><time datetime="2025-01-19T05:19:14.585Z" title="Created 2025-01-18 22:19:14">2025-01-18</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Zishuai Zhang</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>