<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>From Human-Readable to Binary----Optimizing the Mesh Pipeline | Canned Pixels</title><meta name="author" content="Zishuai Zhang,zhangzs2023@163.com"><meta name="copyright" content="Zishuai Zhang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Download the Game DemoYou can download the demo of the game using the link below. Download Game Demo ZIP How to Control the Game W&#x2F;A&#x2F;S&#x2F;D: Press the WASD to control the camera move. J&amp;#x">
<meta property="og:type" content="article">
<meta property="og:title" content="From Human-Readable to Binary----Optimizing the Mesh Pipeline">
<meta property="og:url" content="https://zhangzs11.github.io/2024/10/19/GameEngienII-Assignment08Write-Up/index.html">
<meta property="og:site_name" content="Canned Pixels">
<meta property="og:description" content="Download the Game DemoYou can download the demo of the game using the link below. Download Game Demo ZIP How to Control the Game W&#x2F;A&#x2F;S&#x2F;D: Press the WASD to control the camera move. J&amp;#x">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://zhangzs11.github.io/img/MyAvatar.jpg">
<meta property="article:published_time" content="2024-10-19T06:00:00.000Z">
<meta property="article:modified_time" content="2024-12-17T00:37:29.421Z">
<meta property="article:author" content="Zishuai Zhang">
<meta property="article:tag" content="Computer Graphics, D3D, Game Engine Development">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhangzs11.github.io/img/MyAvatar.jpg"><link rel="shortcut icon" href="/img/MyAvatar.jpg"><link rel="canonical" href="https://zhangzs11.github.io/2024/10/19/GameEngienII-Assignment08Write-Up/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'From Human-Readable to Binary----Optimizing the Mesh Pipeline',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background: linear-gradient(20deg, #b9fbc0, #98f5e1, #90dbf4, #cfbaf0);"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/Funny/Y2KBackgroundNight.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Canned Pixels</span></a><a class="nav-page-title" href="/"><span class="site-name">From Human-Readable to Binary----Optimizing the Mesh Pipeline</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">From Human-Readable to Binary----Optimizing the Mesh Pipeline<a class="post-edit-link" href="null_posts/GameEngienII-Assignment08Write-Up.md" title="Edit" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-10-19T06:00:00.000Z" title="Created 2024-10-19 00:00:00">2024-10-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-12-17T00:37:29.421Z" title="Updated 2024-12-16 17:37:29">2024-12-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/EAE-Game-Engineering-II/">EAE Game Engineering II</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="Download-the-Game-Demo"><a href="#Download-the-Game-Demo" class="headerlink" title="Download the Game Demo"></a>Download the Game Demo</h3><p>You can download the demo of the game using the link below.</p>
<p><a href="/downloads/GameDemo08.zip">Download Game Demo ZIP</a></p>
<h4 id="How-to-Control-the-Game"><a href="#How-to-Control-the-Game" class="headerlink" title="How to Control the Game"></a>How to Control the Game</h4><ul>
<li><strong>W&#x2F;A&#x2F;S&#x2F;D</strong>: Press the WASD to control the camera move.</li>
<li><strong>J&#x2F;K</strong>: Press J or K to turn the camera left or right.</li>
<li><strong>UP&#x2F;DOWN&#x2F;LEFT&#x2F;RIGHT&#x2F;N&#x2F;M</strong>: Press to control the game object (Alien) move.</li>
</ul>
<h1 id="Assignment-08-Description"><a href="#Assignment-08-Description" class="headerlink" title="Assignment 08 Description:"></a>Assignment 08 Description:</h1><ul>
<li><p>Change MeshBuilder tool project to output a binary geometry.</p>
</li>
<li><p>Change run-time mesh representation to load binary geometry.</p>
</li>
<li><p>Understand the different feature and advantage between binary geometry and human-readable formats</p>
</li>
</ul>
<h1 id="Screenshots-of-the-Game"><a href="#Screenshots-of-the-Game" class="headerlink" title="Screenshots of the Game"></a>Screenshots of the Game</h1><div align="center">
  <img src="/images/GameEngine/08/AlienSS.png" alt="Game Screenshot">
  <p>Figure 1. Screenshot loading the recognizable geometry using binary geometry</p>
</div>

<h1 id="An-example-of-a-binary-geometry-file-built-by-MeshBuilder"><a href="#An-example-of-a-binary-geometry-file-built-by-MeshBuilder" class="headerlink" title="An example of a binary geometry file built by MeshBuilder"></a>An example of a binary geometry file built by MeshBuilder</h1><div align="center">
  <img src="/images/GameEngine/08/planeLua.png" alt="Game Screenshot">
  <p>Figure 2. human-readable formats before transform to binary geometry (a plane mesh)</p>
</div>

<div align="center">
  <img src="/images/GameEngine/08/HxDPlaneBin.png" alt="Game Screenshot">
  <p>Figure 3. binary geometry with position and color in vertex data (a plane mesh)</p>
</div>

<h2 id="The-order-of-the-four-things"><a href="#The-order-of-the-four-things" class="headerlink" title="The order of the four things"></a>The order of the four things</h2><ol>
<li><strong>Vertex Count</strong></li>
<li><strong>Vertex Data</strong> (Each vertex contains position and color data)</li>
<li><strong>Index Count</strong></li>
<li><strong>Index Data</strong></li>
</ol>
<h3 id="Why-this-order"><a href="#Why-this-order" class="headerlink" title="Why this order"></a>Why this order</h3><p>The vertex count and index count are placed first as leading information to help the parser know how many vertices and indices to read. This allows for sequential reading from start to finish in a straightforward manner.</p>
<h2 id="Recognize-the-data"><a href="#Recognize-the-data" class="headerlink" title="Recognize the data"></a>Recognize the data</h2><ul>
<li><p><strong>Orange Data:</strong><br><code>04 00</code><br>Vertex count (uint16_t)</p>
</li>
<li><p><strong>Blue Data:</strong><br><code>00 00 20 C0</code><br>Position X (float)<br><code>00 00 00 00</code><br>Position Y (float)<br><code>00 00 20 40</code><br>Position Z (float)</p>
</li>
<li><p><strong>Green Data:</strong><br><code>23</code><br>Color R (uint8_t)<br><code>DE</code><br>Color G (uint8_t)<br><code>68</code><br>Color B (uint8_t)<br><code>FF</code><br>Color A (uint8_t)<br>There are four sets of vertex data, each following the same format.</p>
</li>
<li><p><strong>Red Data:</strong><br><code>06 00</code><br>Index count (uint16_t)</p>
</li>
<li><p><strong>Pink Data:</strong><br><code>00 00</code><br>index[1] (uint16_t)<br><code>01 00</code><br>index[2] (uint16_t)<br>…<br>There are a total of 6 indices.</p>
</li>
</ul>
<h2 id="Advantages-of-Using-Binary-Files"><a href="#Advantages-of-Using-Binary-Files" class="headerlink" title="Advantages of Using Binary Files"></a>Advantages of Using Binary Files</h2><ol>
<li><strong>Storage Efficiency:</strong> Binary files store data directly, avoiding the extra characters present in human-readable formats like Lua (such as {}, &#x3D;). This compresses the file size significantly, especially with large models.</li>
<li><strong>Faster Parsing:</strong> Binary files can be read directly into memory without the need for parsing strings or performing lexical analysis as required by formats like Lua. This greatly enhances runtime loading speed.</li>
</ol>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Load-Time-Comparison-Using-a-more-complex-“Alien”-model"><a href="#Load-Time-Comparison-Using-a-more-complex-“Alien”-model" class="headerlink" title="Load Time Comparison (Using a more complex “Alien” model):"></a><strong>Load Time Comparison</strong> (Using a more complex “Alien” model):</h4><div align="center">
  <img src="/images/GameEngine/08/time_lua.png">
  <p>Figure 4. How long it takes to load the human-readable version</p>
</div>

<div align="center">
  <img src="/images/GameEngine/08/time_bin.png" alt="Game Screenshot">
  <p>Figure 5. How long it takes to load the binary version</p>
</div>

<h4 id="File-Size-Comparison"><a href="#File-Size-Comparison" class="headerlink" title="File Size Comparison:"></a><strong>File Size Comparison:</strong></h4><p>How big (in bytes) the human-readable version Alien mesh is on disk?<br><strong><em>5505KB</em></strong></p>
<p>How big (in bytes) the binary version Alien mesh is on disk?<br><strong><em>299KB</em></strong></p>
<h2 id="Binary-vs-Human-Readable-Format"><a href="#Binary-vs-Human-Readable-Format" class="headerlink" title="Binary vs. Human-Readable Format"></a>Binary vs. Human-Readable Format</h2><h3 id="Advantages-of-Binary-Format"><a href="#Advantages-of-Binary-Format" class="headerlink" title="Advantages of Binary Format:"></a>Advantages of Binary Format:</h3><ol>
<li><strong>Runtime Efficiency:</strong> Binary formats load faster and use less disk space during runtime.</li>
<li><strong>Memory Alignment:</strong> Binary formats can ensure better memory alignment, improving memory access performance.</li>
</ol>
<h3 id="Advantages-of-Human-Readable-Format"><a href="#Advantages-of-Human-Readable-Format" class="headerlink" title="Advantages of Human-Readable Format:"></a>Advantages of Human-Readable Format:</h3><ol>
<li><strong>Readability and Maintainability:</strong> Formats like Lua are easy to read, making them ideal for debugging and viewing model data during development.</li>
<li><strong>Editability:</strong> Human-readable files can be manually edited, which is useful for making quick adjustments during development and testing.</li>
</ol>
<h2 id="Why-Do-We-Use-Binary-Files-at-Runtime-and-Human-Readable-Files-for-Source-Control"><a href="#Why-Do-We-Use-Binary-Files-at-Runtime-and-Human-Readable-Files-for-Source-Control" class="headerlink" title="Why Do We Use Binary Files at Runtime and Human-Readable Files for Source Control?"></a>Why Do We Use Binary Files at Runtime and Human-Readable Files for Source Control?</h2><ul>
<li><strong>Binary Files at Runtime:</strong> They are smaller and faster to load, which is critical for real-time applications like games. Since binary files are compact and machine-readable, they minimize memory usage and disk I&#x2F;O, making the game run more efficiently.</li>
<li><strong>Human-Readable Files in Source Control:</strong> Formats like Lua or JSON are easier to read, understand, and modify by developers. This makes them ideal for storing in source control, where you need to collaborate with others, track changes, and easily edit content.</li>
</ul>
<h2 id="Should-Binary-Geometry-Files-Be-the-Same-for-Different-Platforms"><a href="#Should-Binary-Geometry-Files-Be-the-Same-for-Different-Platforms" class="headerlink" title="Should Binary Geometry Files Be the Same for Different Platforms?"></a>Should Binary Geometry Files Be the Same for Different Platforms?</h2><p>The binary file generated by the MeshBuilder for Direct3D can be the same as the one generated for OpenGL, but it depends on several key factors, including <strong>endianness, data alignment, and platform-specific requirements</strong>.</p>
<p><strong>1. Endianness</strong><br>   Endianness refers to the byte order used to represent multi-byte data types (e.g., uint16_t, float). There are two types:</p>
<ul>
<li><strong>Little-endian:</strong> Low-order bytes are stored at lower memory addresses, used by most x86 and x64 architectures (like Windows).</li>
<li><strong>Big-endian:</strong> High-order bytes are stored at lower memory addresses, used by some other systems or architectures.<br>If target platforms (e.g., Windows and Linux) use different endianness, the binary file will be different. For example, on little-endian platforms, you may write the number 4 as <em>04 00</em> in hexadecimal, but on big-endian platforms, it might be written as <em>00 04</em>.</li>
</ul>
<p><strong>2. Data Alignment</strong><br>   Different platforms or APIs may require different data alignment for performance reasons.<br>   If the alignment requirements differ between Direct3D and OpenGL, the binary file might have different padding between the data structures, making the files different. However, if both platforms share the same alignment rules, the files can be identical.</p>
<p><strong>3. API-Specific Differences</strong><br>   Certain differences between Direct3D and OpenGL can lead to differences in how the binary file is generated:</p>
<ul>
<li><strong>Vertex Index Order:</strong> The winding order of vertices (whether they are clockwise or counterclockwise) might differ between APIs.</li>
<li><strong>Texture Coordinates:</strong> OpenGL uses a different texture coordinate system than Direct3D (origin at the lower-left for OpenGL, and upper-left for Direct3D). If this affects how your vertex data is generated, it could result in differences in the binary file.</li>
</ul>
<p>However, it is also possible to design the system to read the same binary data and then process the loaded data differently based on the target API.</p>
<h1 id="How-to-extract-the-four-pieces-of-data-from-binary-data-at-run-time"><a href="#How-to-extract-the-four-pieces-of-data-from-binary-data-at-run-time" class="headerlink" title="How to extract the four pieces of data from binary data at run-time"></a>How to extract the four pieces of data from binary data at run-time</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Load the binary mesh file</span></span><br><span class="line">Platform::sDataFromFile dataFromFile;</span><br><span class="line"></span><br><span class="line"><span class="type">uintptr_t</span> currentOffset = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(dataFromFile.data);</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> finalOffset = currentOffset + dataFromFile.size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read the vertex count</span></span><br><span class="line"><span class="type">uint16_t</span> vertexCount;</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;vertexCount, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(currentOffset), <span class="built_in">sizeof</span>(vertexCount));</span><br><span class="line">currentOffset += <span class="built_in">sizeof</span>(<span class="type">uint16_t</span>); <span class="comment">// Move to the next block</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Calculate the size of the vertex data</span></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> vertexDataSize = vertexCount * <span class="built_in">sizeof</span>(eae6320::Graphics::VertexFormats::sVertex_mesh);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the vertex data</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>* <span class="type">const</span> vertexArray = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> eae6320::Graphics::VertexFormats::sVertex_mesh*&gt;(currentOffset);</span><br><span class="line">currentOffset += vertexDataSize; <span class="comment">// Move to the next block (index count)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Read the index count</span></span><br><span class="line"><span class="type">uint16_t</span> indexCount;</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;indexCount, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(currentOffset), <span class="built_in">sizeof</span>(indexCount));</span><br><span class="line">currentOffset += <span class="built_in">sizeof</span>(<span class="type">uint16_t</span>); <span class="comment">// Move to the next block (index data)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Calculate the size of the index data</span></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> indexDataSize = indexCount * <span class="built_in">sizeof</span>(<span class="type">uint16_t</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the index data</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>* <span class="type">const</span> indexArray = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">uint16_t</span>*&gt;(currentOffset);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate memory for the mesh</span></span><br><span class="line">cMesh* newMesh = <span class="built_in">new</span> (std::nothrow) <span class="built_in">cMesh</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize the mesh with the vertex and index data</span></span><br><span class="line">result = newMesh-&gt;<span class="built_in">Initialize</span>(vertexArray, vertexCount, indexArray, indexCount)</span><br><span class="line"></span><br><span class="line">o_mesh = newMesh;</span><br></pre></td></tr></table></figure>

<h1 id="Supporting-32-bit-Indices-for-Large-Meshes-in-the-Game-Engine"><a href="#Supporting-32-bit-Indices-for-Large-Meshes-in-the-Game-Engine" class="headerlink" title="Supporting 32-bit Indices for Large Meshes in the Game Engine"></a>Supporting 32-bit Indices for Large Meshes in the Game Engine</h1><p>The original mesh system in the engine supported only <strong>16-bit indices (uint16_t)</strong>, which <strong>limits the maximum number of vertices</strong> in a mesh to 65,535. However, some complex models can have more vertices, requiring to support 32-bit indices (uint32_t).I implemented support for both 16-bit and 32-bit indices, allowing the engine to handle larger models efficiently while still using 16-bit for simple models.</p>
<h2 id="Implementation-Steps"><a href="#Implementation-Steps" class="headerlink" title="Implementation Steps"></a>Implementation Steps</h2><h3 id="1-Binary-Writing-Process"><a href="#1-Binary-Writing-Process" class="headerlink" title="1. Binary Writing Process"></a>1. Binary Writing Process</h3><p>During the <strong>binary mesh writing process</strong>, the engine first reads the <code>vertexCount</code> from the Lua model file. If the vertexCount <strong>exceeds</strong> the limit of 16-bit indices (65,535), the engine uses 32-bit indices (<code>uint32_t</code>) to store the index data in the binary file. Otherwise, it defaults to 16-bit indices (<code>uint16_t</code>).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">bool</span> use32BitIndex = (vertexCount &gt; std::numeric_limits&lt;<span class="type">uint16_t</span>&gt;::<span class="built_in">max</span>());</span><br></pre></td></tr></table></figure>
<p>Based on this, the engine writes the vertex and index data to the binary file. The index size is determined by whether <code>use32BitIndex</code> is true or false.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (use32BitIndex) &#123;</span><br><span class="line">    <span class="comment">// Write 32-bit index data</span></span><br><span class="line">    binaryFile.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(indexData<span class="number">32.</span><span class="built_in">data</span>()), indexCount * <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Write 16-bit index data</span></span><br><span class="line">    binaryFile.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(indexData<span class="number">16.</span><span class="built_in">data</span>()), indexCount * <span class="built_in">sizeof</span>(<span class="type">uint16_t</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-Binary-Reading-and-GPU-Initialization-GPU-Draw"><a href="#2-Binary-Reading-and-GPU-Initialization-GPU-Draw" class="headerlink" title="2. Binary Reading and GPU Initialization, GPU Draw"></a>2. Binary Reading and GPU Initialization, GPU Draw</h3><p>When reading the binary file, the engine first checks the vertexCount. If it exceeds the limit of 65,535, the engine reads the index data using <code>uint32_t</code>. Otherwise, it reads the index data using <code>uint16_t</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Determine whether to use 16-bit or 32-bit indices based on vertex count</span></span><br><span class="line"><span class="type">bool</span> use32BitIndex = (vertexCount &gt; std::numeric_limits&lt;<span class="type">uint16_t</span>&gt;::<span class="built_in">max</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read the index data</span></span><br><span class="line"><span class="type">void</span>* indexArray = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span> (use32BitIndex)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">const</span> <span class="type">size_t</span> indexDataSize = indexCount * <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">   IndexArray = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint32_t</span>*&gt;(currentOffset);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">const</span> <span class="type">size_t</span> indexDataSize = indexCount * <span class="built_in">sizeof</span>(<span class="type">uint16_t</span>);</span><br><span class="line">   indexArray = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint16_t</span>*&gt;(currentOffset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Once the index data has been read, the GPU resources, like the <strong>index buffer</strong>, are created <strong>accordingly</strong>. If the model uses 32-bit indices, the Direct3D or OpenGL API is instructed to <strong>create and use the appropriate format</strong>.</p>
<p>For Direct3D, this looks like:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DXGI_FORMAT indexFormat = use32BitIndex ? DXGI_FORMAT_R32_UINT : DXGI_FORMAT_R16_UINT;</span><br><span class="line">direct3dImmediateContext-&gt;<span class="built_in">IASetIndexBuffer</span>(m_indexBuffer, indexFormat, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>For OpenGL, you can bind the correct index type (<strong>GL_UNSIGNED_INT for 32-bit or GL_UNSIGNED_SHORT for 16-bit</strong>).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> GLenum indexType = use32BitIndex ? GL_UNSIGNED_INT : GL_UNSIGNED_SHORT;</span><br><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, indexCount, indexType, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure>

<h3 id="3-Adjusting-Indices-for-Correct-Winding-Order"><a href="#3-Adjusting-Indices-for-Correct-Winding-Order" class="headerlink" title="3. Adjusting Indices for Correct Winding Order"></a>3. Adjusting Indices for Correct Winding Order</h3><p>To ensure proper triangle winding, the engine must handle the conversion (in my Engine design, D3D API only) for both 16-bit and 32-bit indices. This is handled as follows:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConvertIndicesToCCW</span><span class="params">(<span class="type">void</span>* indexData, <span class="type">size_t</span> indexCount, <span class="type">bool</span> use32BitIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (use32BitIndex) &#123;</span><br><span class="line">        <span class="type">uint32_t</span>* indices = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint32_t</span>*&gt;(indexData);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; indexCount; i += <span class="number">3</span>) &#123;</span><br><span class="line">            std::<span class="built_in">swap</span>(indices[i + <span class="number">1</span>], indices[i + <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">uint16_t</span>* indices = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint16_t</span>*&gt;(indexData);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; indexCount; i += <span class="number">3</span>) &#123;</span><br><span class="line">            std::<span class="built_in">swap</span>(indices[i + <span class="number">1</span>], indices[i + <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Screenshot-of-more-Complex-Helix-Model-Using-32-bit-Index-Data"><a href="#Screenshot-of-more-Complex-Helix-Model-Using-32-bit-Index-Data" class="headerlink" title="Screenshot of more Complex Helix Model Using 32-bit Index Data"></a>Screenshot of more Complex Helix Model Using 32-bit Index Data</h2><div align="center">
  <img src="/images/GameEngine/08/32bitIndex.png" alt="Game Screenshot">
  <p>Figure 6. Helix Model Using 32-bit</p>
</div>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://zhangzs11.github.io">Zishuai Zhang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://zhangzs11.github.io/2024/10/19/GameEngienII-Assignment08Write-Up/">https://zhangzs11.github.io/2024/10/19/GameEngienII-Assignment08Write-Up/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/MyAvatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/10/25/GameEngine-System%20Proposal/" title="EAEGameEngineII-Graphics System Proposal"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">EAEGameEngineII-Graphics System Proposal</div></div><div class="info-2"><div class="info-item-1">Engine System Proposal: Graphics Module EnhancementsOverviewThe proposed Graphics Module will provide advanced graphical effects to support high-quality visuals in games. The module will offer features like texture handling, skyboxes, shadows, lighting, and anti-aliasing, allowing users to create visually rich environments with realistic lighting and shading. This system will be a crucial addition for a classmate looking to implement graphical fidelity in their final project game, providing...</div></div></div></a><a class="pagination-related" href="/2024/10/05/Ray%20Tracing%20in%20CUDA%20(03)%20-----%20Camera%20and%20Defocus%20Bulr/" title="Ray Tracing in CUDA (03) - Camera and Defocus Blur"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">Ray Tracing in CUDA (03) - Camera and Defocus Blur</div></div><div class="info-2"><div class="info-item-1">Camera ClassCamera Constructor1234567891011121314__device__ camera(vec3 lookfrom, vec3 lookat, vec3 vup, float vfov, float aspect, float aperture, float focus_dist) &#123;    // vfov is top to bottom in degrees    lens_radius = aperture / 2.0f;    float theta = vfov * ((float)M_PI) / 180.0f;    float half_height = tan(theta / 2.0f);    float half_width = aspect * half_height;    origin = lookfrom;    w = unit_vector(lookfrom - lookat);    u = unit_vector(cross(vup, w));    v = cross(w, u);  ...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/MyAvatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Zishuai Zhang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/zhangzs11" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:zhangzs2023@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Download-the-Game-Demo"><span class="toc-number">1.</span> <span class="toc-text">Download the Game Demo</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#How-to-Control-the-Game"><span class="toc-number">1.1.</span> <span class="toc-text">How to Control the Game</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Assignment-08-Description"><span class="toc-number"></span> <span class="toc-text">Assignment 08 Description:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Screenshots-of-the-Game"><span class="toc-number"></span> <span class="toc-text">Screenshots of the Game</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#An-example-of-a-binary-geometry-file-built-by-MeshBuilder"><span class="toc-number"></span> <span class="toc-text">An example of a binary geometry file built by MeshBuilder</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#The-order-of-the-four-things"><span class="toc-number"></span> <span class="toc-text">The order of the four things</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Why-this-order"><span class="toc-number">1.</span> <span class="toc-text">Why this order</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Recognize-the-data"><span class="toc-number"></span> <span class="toc-text">Recognize the data</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Advantages-of-Using-Binary-Files"><span class="toc-number"></span> <span class="toc-text">Advantages of Using Binary Files</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Example"><span class="toc-number">1.</span> <span class="toc-text">Example</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Load-Time-Comparison-Using-a-more-complex-%E2%80%9CAlien%E2%80%9D-model"><span class="toc-number">1.1.</span> <span class="toc-text">Load Time Comparison (Using a more complex “Alien” model):</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#File-Size-Comparison"><span class="toc-number">1.2.</span> <span class="toc-text">File Size Comparison:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Binary-vs-Human-Readable-Format"><span class="toc-number"></span> <span class="toc-text">Binary vs. Human-Readable Format</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Advantages-of-Binary-Format"><span class="toc-number">1.</span> <span class="toc-text">Advantages of Binary Format:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Advantages-of-Human-Readable-Format"><span class="toc-number">2.</span> <span class="toc-text">Advantages of Human-Readable Format:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Why-Do-We-Use-Binary-Files-at-Runtime-and-Human-Readable-Files-for-Source-Control"><span class="toc-number"></span> <span class="toc-text">Why Do We Use Binary Files at Runtime and Human-Readable Files for Source Control?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Should-Binary-Geometry-Files-Be-the-Same-for-Different-Platforms"><span class="toc-number"></span> <span class="toc-text">Should Binary Geometry Files Be the Same for Different Platforms?</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#How-to-extract-the-four-pieces-of-data-from-binary-data-at-run-time"><span class="toc-number"></span> <span class="toc-text">How to extract the four pieces of data from binary data at run-time</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Supporting-32-bit-Indices-for-Large-Meshes-in-the-Game-Engine"><span class="toc-number"></span> <span class="toc-text">Supporting 32-bit Indices for Large Meshes in the Game Engine</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Implementation-Steps"><span class="toc-number"></span> <span class="toc-text">Implementation Steps</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Binary-Writing-Process"><span class="toc-number">1.</span> <span class="toc-text">1. Binary Writing Process</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Binary-Reading-and-GPU-Initialization-GPU-Draw"><span class="toc-number">2.</span> <span class="toc-text">2. Binary Reading and GPU Initialization, GPU Draw</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Adjusting-Indices-for-Correct-Winding-Order"><span class="toc-number">3.</span> <span class="toc-text">3. Adjusting Indices for Correct Winding Order</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Screenshot-of-more-Complex-Helix-Model-Using-32-bit-Index-Data"><span class="toc-number"></span> <span class="toc-text">Screenshot of more Complex Helix Model Using 32-bit Index Data</span></a></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/06/SoftRender--Triangle%20Rasterization/" title="Software Rasterizer - Triangle Rasterization">Software Rasterizer - Triangle Rasterization</a><time datetime="2025-01-07T00:14:31.379Z" title="Created 2025-01-06 17:14:31">2025-01-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/06/SoftRender--Wireframe%20Rendering/" title="Software Rasterizer - Wireframe Clipping and Rendering">Software Rasterizer - Wireframe Clipping and Rendering</a><time datetime="2025-01-06T21:55:42.372Z" title="Created 2025-01-06 14:55:42">2025-01-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/16/Graphics_System-Shadow/" title="Graphics_System-Shadow Mapping">Graphics_System-Shadow Mapping</a><time datetime="2024-12-16T07:00:00.000Z" title="Created 2024-12-16 00:00:00">2024-12-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/02/GameEngineII-FInal%20Project/" title="EAEGameEngineII-Final Game Write-Up">EAEGameEngineII-Final Game Write-Up</a><time datetime="2024-12-02T07:00:00.000Z" title="Created 2024-12-02 00:00:00">2024-12-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/13/GameEngineII-Final_Project_Proposal/" title="EAEGameEngineII-Final_Project_Proposal">EAEGameEngineII-Final_Project_Proposal</a><time datetime="2024-11-13T07:00:00.000Z" title="Created 2024-11-13 00:00:00">2024-11-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Zishuai Zhang</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>