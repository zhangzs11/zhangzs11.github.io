<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>GraphicsSystem-Normal Mapping | Canned Pixels</title><meta name="author" content="Zishuai Zhang,zhangzs2023@163.com"><meta name="copyright" content="Zishuai Zhang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Normal MappingNormal mapping is a technique to simulate the appearance of detailed surface geometry on a simpler model by altering the surface normal at the pixel level. Inputs in the Vertex ShaderNor">
<meta property="og:type" content="article">
<meta property="og:title" content="GraphicsSystem-Normal Mapping">
<meta property="og:url" content="https://zhangzs11.github.io/2025/01/18/GraphicsSystem-NormalMapping/index.html">
<meta property="og:site_name" content="Canned Pixels">
<meta property="og:description" content="Normal MappingNormal mapping is a technique to simulate the appearance of detailed surface geometry on a simpler model by altering the surface normal at the pixel level. Inputs in the Vertex ShaderNor">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://zhangzs11.github.io/img/MyAvatar.jpg">
<meta property="article:published_time" content="2025-01-18T18:19:54.862Z">
<meta property="article:modified_time" content="2025-02-02T23:30:05.823Z">
<meta property="article:author" content="Zishuai Zhang">
<meta property="article:tag" content="Computer Graphics, D3D, Game Engine Development">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhangzs11.github.io/img/MyAvatar.jpg"><link rel="shortcut icon" href="/img/MyAvatar.jpg"><link rel="canonical" href="https://zhangzs11.github.io/2025/01/18/GraphicsSystem-NormalMapping/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'GraphicsSystem-Normal Mapping',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background: linear-gradient(20deg, #b9fbc0, #98f5e1, #90dbf4, #cfbaf0);"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/Funny/xuanyuanjian_sea.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Canned Pixels</span></a><a class="nav-page-title" href="/"><span class="site-name">GraphicsSystem-Normal Mapping</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">GraphicsSystem-Normal Mapping<a class="post-edit-link" href="null_posts/GraphicsSystem-NormalMapping.md" title="Edit" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-01-18T18:19:54.862Z" title="Created 2025-01-18 11:19:54">2025-01-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-02-02T23:30:05.823Z" title="Updated 2025-02-02 16:30:05">2025-02-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Game-Engine/">Game Engine</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Normal-Mapping"><a href="#Normal-Mapping" class="headerlink" title="Normal Mapping"></a>Normal Mapping</h1><p>Normal mapping is a technique to simulate the appearance of detailed surface geometry on a simpler model by altering the surface normal at the pixel level.</p>
<h2 id="Inputs-in-the-Vertex-Shader"><a href="#Inputs-in-the-Vertex-Shader" class="headerlink" title="Inputs in the Vertex Shader"></a>Inputs in the Vertex Shader</h2><p>Normal mapping in the vertex shader relies on specific inputs to calculate the tangent space necessary for lighting calculations. These inputs are:<br><code>in const float3 i_vertexNormal : NORMAL;
in const float3 i_vertexTangent : TANGENT;</code></p>
<h3 id="Why-these-Inputs-are-needed"><a href="#Why-these-Inputs-are-needed" class="headerlink" title="Why these Inputs are needed?"></a>Why these Inputs are needed?</h3><p>The combination of the normal and tangent vectors allows for construction of the Tangent-Bitangent-Normal(TBN) matrix, which is essential for transform normal map data from tangent space into world space. Without these inputs, the shader would be unable to correctly interpret the details encoded in the normal map.</p>
<h2 id="Transformation-in-the-Vertex-Shader"><a href="#Transformation-in-the-Vertex-Shader" class="headerlink" title="Transformation in the Vertex Shader"></a>Transformation in the Vertex Shader</h2><p>In the vertex shader, the normals and tangent are transformed from local space to world space.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">o_vertexNormal_world = <span class="built_in">mul</span>( (float3x3) g_transform_localToWorld_Inv_Transpose, i_vertexNormal );</span><br><span class="line"></span><br><span class="line">o_vertexTangent_world = <span class="built_in">float4</span>(<span class="built_in">mul</span>((float3x3) g_transform_localToWorld, i_vertexTangent), <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="Transforming-the-Normal"><a href="#Transforming-the-Normal" class="headerlink" title="Transforming the Normal"></a>Transforming the Normal</h3><p>The normal is transformed using the inverse(1st) transpose(2nd) of the local-to-world matrix(<code>g_transform_localToWorld_Inv_Transpose</code>).<br>This ensures the normal vector remains correctly oriented, as normal vectors do not transform the same way as positions.</p>
<h3 id="Transforming-the-Tangent"><a href="#Transforming-the-Tangent" class="headerlink" title="Transforming the Tangent"></a>Transforming the Tangent</h3><p>The tangent is transformed directly using the <code>g_transform_localToWorld</code> matrix.<br>A <code>w</code> component of <code>1.0</code> is appended to maintain compatibility for potential homogeneous transformations.</p>
<h2 id="Processing-in-the-Pixel-Shader"><a href="#Processing-in-the-Pixel-Shader" class="headerlink" title="Processing in the Pixel Shader"></a>Processing in the Pixel Shader</h2><p>Once reach the pixel shader, further processing occurs to incorporate the normal map’s information. Here is the relevant shader snippet.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Normalize the inputs</span></span><br><span class="line">i_fragmentNormal_world = <span class="built_in">normalize</span>(i_fragmentNormal_world);</span><br><span class="line">i_fragmentTangent_world.xyz = <span class="built_in">normalize</span>(i_fragmentTangent_world.xyz);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sample the normal map</span></span><br><span class="line">float3 normalMapSample = g_texture<span class="number">1.</span><span class="built_in">Sample</span>(g_sampler, i_fragmentUV).rgb;</span><br><span class="line">float3 bumpedNormalW = <span class="built_in">NormalSampleToWorldSpace</span>(normalMapSample, i_fragmentNormal_world, i_fragmentTangent_world);</span><br></pre></td></tr></table></figure></p>
<ol>
<li><strong>Normalizing Inputs :</strong> ensure their magnitude is consistent for accurate lighting calculations.</li>
<li><strong>Sampling the Normal Map :</strong> Sampler fetches the RGB values from the normal map texture. The RGB values represent the surface normal in tangent space, encoded in the [0,1] range.</li>
<li><strong>Transforming the Normal Map Data :</strong> The <code>NormalSampleToWorldSpace</code> function converts the sampled normal from tangent space to world space using the TBN matrix.</li>
</ol>
<h3 id="The-NormalSampleToWorldSpace-Function"><a href="#The-NormalSampleToWorldSpace-Function" class="headerlink" title="The NormalSampleToWorldSpace Function"></a>The <code>NormalSampleToWorldSpace</code> Function</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">float3 <span class="title">NormalSampleToWorldSpace</span><span class="params">(float3 normalMapSample, float3 uintNormalW, float4 tangentW)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    float3 normalT = <span class="number">2.0f</span> * normalMapSample - <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    float3 N = uintNormalW;</span><br><span class="line">    float3 T = <span class="built_in">normalize</span>(tangentW.xyz - <span class="built_in">dot</span>(tangentW.xyz, N) * N);</span><br><span class="line">    float3 B = <span class="built_in">cross</span>(N, T);</span><br><span class="line"></span><br><span class="line">    float3x3 TBN = <span class="built_in">float3x3</span>(T, B, N);</span><br><span class="line">    float3x3 TBN_Transpose = <span class="built_in">transpose</span>(TBN);</span><br><span class="line"></span><br><span class="line">    float3 bumpedNormalW = <span class="built_in">mul</span>(TBN_Transpose, normalT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bumpedNormalW;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Step-1-Decode-the-Normal-Map-Sample"><a href="#Step-1-Decode-the-Normal-Map-Sample" class="headerlink" title="Step 1 : Decode the Normal Map Sample"></a>Step 1 : Decode the Normal Map Sample</h4><p><code>float3 normalT = 2.0f * normalMapSample - 1.0f;</code></p>
<p>By transforming the RGB values to the [-1,1] range, they represent vectors in tangent space.</p>
<h4 id="Step-2-Construct-the-TBN-Matrix"><a href="#Step-2-Construct-the-TBN-Matrix" class="headerlink" title="Step 2 : Construct the TBN Matrix"></a>Step 2 : Construct the TBN Matrix</h4><ul>
<li>N:<br>The normalized world-space normal vector.</li>
<li>T:<br>The tangent vector is orthogonalized with respect to the normal to ensure a proper basis vector.<br>This is achieved using:<br><code>float3 T = normalize(tangentW.xyz - dot(tangentW.xyz, N) * N);</code></li>
<li>B:<br>The bitangent vector is calculated as the cross product of the normal and tangent:<br><code>float3 B = cross(N, T);</code></li>
</ul>
<p>These three vectors form the tangent space basis matrix(<code>TBN</code>).</p>
<h4 id="Step-3-Transform-the-Tangent-Space-Normal-to-World-Space"><a href="#Step-3-Transform-the-Tangent-Space-Normal-to-World-Space" class="headerlink" title="Step 3 : Transform the Tangent Space Normal to World Space"></a>Step 3 : Transform the Tangent Space Normal to World Space</h4><p><code>float3 bumpedNormalW = mul(TBN_Transpose, normalT);</code><br>The sampled tangent-space normal is multiplied by the TBN matrix to transform it into world space.</p>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output :"></a>Output :</h4><p>The final result, <code>bumpedNormalW</code>, is the normal vector in world space, incorporating both the geometry’s orientation and the details from the normal map.</p>
<h2 id="Final-Output-and-Usage"><a href="#Final-Output-and-Usage" class="headerlink" title="Final Output and Usage"></a>Final Output and Usage</h2><p>The bumpedNormalW is now ready for use in lighting calculation, such as<br><code>float NdotL = max(dot(bumpedNormalW, lightDirection), 0.0);</code><br>This allows the lighting to reflect the surface details encoded in the normal map, provided the illusion of complex geometry on a simpler model.</p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>The workflow of implementing normal mapping involves:</p>
<ol>
<li>Transforming the vertex normals and tangents to world space in the vertex shader.</li>
<li>Sampling the normal map in the pixel shader and converting it to the [-1. 1] range.</li>
<li>Constructing a tangent space basis matrix (TBN) using the normal, tangent and bitangent.</li>
<li>Transforming the tangent-space normal into world space using TBN matrix.</li>
<li>Using the transformed normal in lighting calculations to achieve realistic surface details.</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://zhangzs11.github.io">Zishuai Zhang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://zhangzs11.github.io/2025/01/18/GraphicsSystem-NormalMapping/">https://zhangzs11.github.io/2025/01/18/GraphicsSystem-NormalMapping/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/MyAvatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/01/18/GraphicsSystem-FXAA/" title="GraphicsSystem-FXAA"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">GraphicsSystem-FXAA</div></div><div class="info-2"><div class="info-item-1">FXAAThis pixel shader implements Fast Approximate Anti-Aliasing (FXAA), a post-processing technique designed to smooth edges and reduce aliasing in rendered images.This algorithm does not approach the problem from the perspective of geometry or line segments but instead relies solely on the luminance information of the current pixel and its surrounding pixels to detect edges and apply smoothing. Luminance CalculationConvert the pixel’s RGB color into a single luminance value, representing...</div></div></div></a><a class="pagination-related" href="/2025/01/18/GraphicsSystem-Skybox/" title="GraphicsSystem-Skybox"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">GraphicsSystem-Skybox</div></div><div class="info-2"><div class="info-item-1">Skybox RenderingA skybox is a cube-shaped environment texture that surrounds the entire scene, simulating a far-away background. Skybox WorkflowThe skybox rendering process is performed after drawing the scene’s meshed. It involves:  Vertex transformations : A cube is used as the geometry for the skybox. Transform the cube vertices to match the camera’s perspective without considering depth. Sampling a cube texture : Use a texture cube (TextureCube) to display the environment.  Combining...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/MyAvatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Zishuai Zhang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">38</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/zhangzs11" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:zhangzs2023@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Normal-Mapping"><span class="toc-number">1.</span> <span class="toc-text">Normal Mapping</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Inputs-in-the-Vertex-Shader"><span class="toc-number">1.1.</span> <span class="toc-text">Inputs in the Vertex Shader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Why-these-Inputs-are-needed"><span class="toc-number">1.1.1.</span> <span class="toc-text">Why these Inputs are needed?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Transformation-in-the-Vertex-Shader"><span class="toc-number">1.2.</span> <span class="toc-text">Transformation in the Vertex Shader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Transforming-the-Normal"><span class="toc-number">1.2.1.</span> <span class="toc-text">Transforming the Normal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Transforming-the-Tangent"><span class="toc-number">1.2.2.</span> <span class="toc-text">Transforming the Tangent</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Processing-in-the-Pixel-Shader"><span class="toc-number">1.3.</span> <span class="toc-text">Processing in the Pixel Shader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#The-NormalSampleToWorldSpace-Function"><span class="toc-number">1.3.1.</span> <span class="toc-text">The NormalSampleToWorldSpace Function</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Step-1-Decode-the-Normal-Map-Sample"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">Step 1 : Decode the Normal Map Sample</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step-2-Construct-the-TBN-Matrix"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">Step 2 : Construct the TBN Matrix</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step-3-Transform-the-Tangent-Space-Normal-to-World-Space"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">Step 3 : Transform the Tangent Space Normal to World Space</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Output"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">Output :</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Final-Output-and-Usage"><span class="toc-number">1.4.</span> <span class="toc-text">Final Output and Usage</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Summary"><span class="toc-number">1.4.1.</span> <span class="toc-text">Summary</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/20/GraphicsSystem-DeferredRendering/" title="GraphicsSystem-Deferred Rendering">GraphicsSystem-Deferred Rendering</a><time datetime="2025-01-20T21:05:08.640Z" title="Created 2025-01-20 14:05:08">2025-01-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/18/GraphicsSystem-FXAA/" title="GraphicsSystem-FXAA">GraphicsSystem-FXAA</a><time datetime="2025-01-19T05:19:14.585Z" title="Created 2025-01-18 22:19:14">2025-01-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/18/GraphicsSystem-NormalMapping/" title="GraphicsSystem-Normal Mapping">GraphicsSystem-Normal Mapping</a><time datetime="2025-01-18T18:19:54.862Z" title="Created 2025-01-18 11:19:54">2025-01-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/18/GraphicsSystem-Skybox/" title="GraphicsSystem-Skybox">GraphicsSystem-Skybox</a><time datetime="2025-01-18T18:19:22.199Z" title="Created 2025-01-18 11:19:22">2025-01-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/16/Graphics_System-Shadow/" title="GraphicsSystem-Shadow Mapping">GraphicsSystem-Shadow Mapping</a><time datetime="2024-12-16T07:00:00.000Z" title="Created 2024-12-16 00:00:00">2024-12-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Zishuai Zhang</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>