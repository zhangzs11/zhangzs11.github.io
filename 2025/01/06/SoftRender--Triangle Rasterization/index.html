<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Software Rasterizer - Triangle Rasterization | Canned Pixels</title><meta name="author" content="Zishuai Zhang,zhangzs2023@163.com"><meta name="copyright" content="Zishuai Zhang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Introduction to RasterizationRasterization is a critical step in the rendering pipeline, where transformed and clipped 3D triangles are converted into 2D pixels on the screen. This process determines">
<meta property="og:type" content="article">
<meta property="og:title" content="Software Rasterizer - Triangle Rasterization">
<meta property="og:url" content="https://zhangzs11.github.io/2025/01/06/SoftRender--Triangle%20Rasterization/index.html">
<meta property="og:site_name" content="Canned Pixels">
<meta property="og:description" content="Introduction to RasterizationRasterization is a critical step in the rendering pipeline, where transformed and clipped 3D triangles are converted into 2D pixels on the screen. This process determines">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://zhangzs11.github.io/img/MyAvatar.jpg">
<meta property="article:published_time" content="2025-01-07T00:14:31.379Z">
<meta property="article:modified_time" content="2025-01-08T16:15:30.744Z">
<meta property="article:author" content="Zishuai Zhang">
<meta property="article:tag" content="Computer Graphics, D3D, Game Engine Development">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhangzs11.github.io/img/MyAvatar.jpg"><link rel="shortcut icon" href="/img/MyAvatar.jpg"><link rel="canonical" href="https://zhangzs11.github.io/2025/01/06/SoftRender--Triangle%20Rasterization/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Software Rasterizer - Triangle Rasterization',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background: linear-gradient(20deg, #b9fbc0, #98f5e1, #90dbf4, #cfbaf0);"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/Funny/sunsetflower.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Canned Pixels</span></a><a class="nav-page-title" href="/"><span class="site-name">Software Rasterizer - Triangle Rasterization</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Software Rasterizer - Triangle Rasterization<a class="post-edit-link" href="null_posts/SoftRender--Triangle Rasterization.md" title="Edit" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-01-07T00:14:31.379Z" title="Created 2025-01-06 17:14:31">2025-01-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-01-08T16:15:30.744Z" title="Updated 2025-01-08 09:15:30">2025-01-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Software-Rasterizer/">Software Rasterizer</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Introduction-to-Rasterization"><a href="#Introduction-to-Rasterization" class="headerlink" title="Introduction to Rasterization"></a>Introduction to Rasterization</h1><p>Rasterization is a critical step in the rendering pipeline, where transformed and clipped 3D triangles are converted into 2D pixels on the screen. This process determines which pixels are covered by each triangle and computes the necessary data for rendering them accurately. Here is the break down the steps leading up to rasterization and what happens during this process:</p>
<h2 id="Vertex-Processing"><a href="#Vertex-Processing" class="headerlink" title="Vertex Processing"></a>Vertex Processing</h2><h3 id="Vertex-Shader-Transformation"><a href="#Vertex-Shader-Transformation" class="headerlink" title="Vertex Shader Transformation:"></a>Vertex Shader Transformation:</h3><ul>
<li>Vertex positions, initially defined in <strong>object space</strong>, are transformed into <strong>clip space</strong> by the vertex shader. This involves applying the model, view, and projection matrices to the vertices.</li>
<li>The result is a set of <strong>homogeneous coordinates in clip space</strong>, where the geometry is prepared for clipping.</li>
</ul>
<h3 id="Clipping"><a href="#Clipping" class="headerlink" title="Clipping:"></a>Clipping:</h3><ul>
<li>Triangles that lie partially or completely outside the view frustum are clipped against its six planes (near, far, left, right, top, and bottom).</li>
<li>New vertices may be created during clipping to ensure that only the visible portions of triangles proceed to the next step.</li>
</ul>
<h3 id="Perspective-Division"><a href="#Perspective-Division" class="headerlink" title="Perspective Division:"></a>Perspective Division:</h3><p><strong>After clipping</strong>, the homogeneous coordinates are <strong>divided by the w-component</strong> to convert them into normalized device coordinates (NDC). This maps all visible geometry to a canonical cube with coordinates ranging from −1 to 1 in all axes. (maybe different in other API)</p>
<h3 id="Viewport-Transformation"><a href="#Viewport-Transformation" class="headerlink" title="Viewport Transformation:"></a>Viewport Transformation:</h3><p>The NDC coordinates are scaled and shifted to <strong>fit the viewport dimensions in screen space</strong>. This ensures that the geometry is correctly positioned on the 2D screen.</p>
<h2 id="Triangle-Rasterization"><a href="#Triangle-Rasterization" class="headerlink" title="Triangle Rasterization"></a>Triangle Rasterization</h2><p>Once the triangle vertices are in screen space, rasterization begins:</p>
<h3 id="Determining-Covered-Pixels"><a href="#Determining-Covered-Pixels" class="headerlink" title="Determining Covered Pixels:"></a>Determining Covered Pixels:</h3><ul>
<li>The triangle is broken down into scanlines, where each scanline corresponds to a horizontal row of pixels.</li>
<li>For each scanline, the algorithm determines the left and right bounds of the triangle by interpolating the triangle edges.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeviceContext::drawTriangle</span><span class="params">(SimpleVertex v1, SimpleVertex v2, SimpleVertex v3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SimpleVertex temp;               <span class="comment">//make v1 on the top, v2 on the middle</span></span><br><span class="line">	<span class="keyword">if</span> (v<span class="number">1.</span>Pos.y &gt; v<span class="number">2.</span>Pos.y) &#123;</span><br><span class="line">		temp = v1;</span><br><span class="line">		v1 = v2;</span><br><span class="line">		v2 = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (v<span class="number">1.</span>Pos.y &gt; v<span class="number">3.</span>Pos.y) &#123;</span><br><span class="line">		temp = v1;</span><br><span class="line">		v1 = v3;</span><br><span class="line">		v3 = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (v<span class="number">2.</span>Pos.y &gt; v<span class="number">3.</span>Pos.y) &#123;</span><br><span class="line">		temp = v2;</span><br><span class="line">		v2 = v3;</span><br><span class="line">		v3 = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (v<span class="number">2.</span>Pos.y == v<span class="number">3.</span>Pos.y) &#123;       <span class="comment">//if is already Top triangle</span></span><br><span class="line">		<span class="built_in">fillBottomFlatTriangle</span>(v1, v2, v3);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (v<span class="number">1.</span>Pos.y == v<span class="number">2.</span>Pos.y) &#123;  <span class="comment">//if is already Bottom triangle</span></span><br><span class="line">		<span class="built_in">fillTopFlatTriangle</span>(v1, v2, v3);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fillBottomFlatTriangle</span>(v1, v2, v3);</span><br><span class="line">		<span class="built_in">fillTopFlatTriangle</span>(v2, v1, v3);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Interpolating-Attributes"><a href="#Interpolating-Attributes" class="headerlink" title="Interpolating Attributes:"></a>Interpolating Attributes:</h3><ul>
<li>Attributes such as texture coordinates (UVs), normals, and world positions are interpolated across the triangle’s surface.</li>
<li><strong>Perspective-Correct Interpolation</strong> is used to ensure accurate rendering:<ul>
<li>Attributes are divided by their w-component during interpolation.</li>
<li>After interpolation, they are multiplied back by w.</li>
</ul>
</li>
</ul>
<h4 id="Step1"><a href="#Step1" class="headerlink" title="Step1:"></a>Step1:</h4><p><strong>invslope1</strong> and <strong>invslope2</strong> represent the horizontal movement of edges v1-&gt;v2 and v1-&gt;v3, respecticely, <strong>for each vertical pixel (y-axis change by 1)</strong><br>Ensure that invslope1 always corresponds to the left edge, and invslope2 corresponds to the right edge<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> invslope1 = (v<span class="number">3.</span>Pos.x - v<span class="number">1.</span>Pos.x) / (v<span class="number">3.</span>Pos.y - v<span class="number">1.</span>Pos.y);</span><br><span class="line"><span class="type">double</span> invslope2 = (v<span class="number">3.</span>Pos.x - v<span class="number">2.</span>Pos.x) / (v<span class="number">3.</span>Pos.y - v<span class="number">2.</span>Pos.y);</span><br><span class="line"><span class="type">float</span> curx1 = v<span class="number">3.</span>Pos.x;</span><br><span class="line"><span class="type">float</span> curx2 = v<span class="number">3.</span>Pos.x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (invslope1 &lt; invslope2) &#123;<span class="comment">//invslope1, v1 preseant the left edge </span></span><br><span class="line">	<span class="type">float</span> temp;</span><br><span class="line">	temp = invslope1;</span><br><span class="line">	invslope1 = invslope2;</span><br><span class="line">	invslope2 = temp;</span><br><span class="line">	SimpleVertex temp1;</span><br><span class="line">	temp1 = v1;</span><br><span class="line">	v1 = v2;</span><br><span class="line">	v2 = temp1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Step2"><a href="#Step2" class="headerlink" title="Step2:"></a>Step2:</h4><p><strong>dx,dx:</strong><br>Compute the interpolation increments for each pixel. These are <strong>constants</strong> and can be precomputed as <strong>dx</strong> and <strong>dy</strong>.</p>
<p><strong>dxdenominator, dydenominator:</strong><br><strong>The increment of the perspective-correct denominator</strong> in the x and y directions.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VECTOR4 dx = <span class="built_in">VECTOR4</span>((-v<span class="number">3.</span>Pos.y + v<span class="number">2.</span>Pos.y) / <span class="number">2</span>, (-v<span class="number">1.</span>Pos.y + v<span class="number">3.</span>Pos.y) / <span class="number">2</span>, (-v<span class="number">2.</span>Pos.y + v<span class="number">1.</span>Pos.y) / <span class="number">2</span>, <span class="number">1</span>) / <span class="built_in">CalTriangleArea</span>(v<span class="number">1.</span>Pos, v<span class="number">2.</span>Pos, v<span class="number">3.</span>Pos);</span><br><span class="line">VECTOR4 dy = <span class="built_in">VECTOR4</span>((-v<span class="number">2.</span>Pos.x + v<span class="number">3.</span>Pos.x) / <span class="number">2</span>, (-v<span class="number">3.</span>Pos.x + v<span class="number">1.</span>Pos.x) / <span class="number">2</span>, (-v<span class="number">1.</span>Pos.x + v<span class="number">2.</span>Pos.x) / <span class="number">2</span>, <span class="number">1</span>) / <span class="built_in">CalTriangleArea</span>(v<span class="number">1.</span>Pos, v<span class="number">2.</span>Pos, v<span class="number">3.</span>Pos);</span><br><span class="line"><span class="type">float</span> dxdenominator = dx.x * v<span class="number">1.</span>Pos.w + dx.y * v<span class="number">2.</span>Pos.w + dx.z * v<span class="number">3.</span>Pos.w;</span><br><span class="line"><span class="type">float</span> dydenominator = dy.x * v<span class="number">1.</span>Pos.w + dy.y * v<span class="number">2.</span>Pos.w + dy.z * v<span class="number">3.</span>Pos.w;</span><br></pre></td></tr></table></figure></p>
<h4 id="Step3"><a href="#Step3" class="headerlink" title="Step3:"></a>Step3:</h4><p>After obtaining the increments for the numerator and denominator, perform incremental rasterization interpolation(UV is used as an example here).<br>Initialize the numerator and denominator for UV;<br>The perspective-correct UV numerator increments are calculated here, while the denominator increments (dxdenominator, dydenuminator) are already computed and are universal for all attributes.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VECTOR4 uv = v<span class="number">3.</span>uv;                     <span class="comment">// Initialize UV</span></span><br><span class="line">VECTOR4 uvnumerator = v<span class="number">3.</span>uv * v<span class="number">3.</span>Pos.w; <span class="comment">// Initialize UV Numerator = UV * w</span></span><br><span class="line"><span class="type">float</span> uvdenominator = v<span class="number">3.</span>Pos.w;         <span class="comment">// Initialize UV Denominator = w</span></span><br><span class="line"><span class="comment">//Compute the perspective-correct UV numerator increments</span></span><br><span class="line">VECTOR4 uvdxnnumerator = v<span class="number">1.</span>uv * v<span class="number">1.</span>Pos.w * dx.x + v<span class="number">2.</span>uv * v<span class="number">2.</span>Pos.w * dx.y + v<span class="number">3.</span>uv * v<span class="number">3.</span>Pos.w * dx.z;<span class="comment">//UV numerator increment in x direction</span></span><br><span class="line">VECTOR4 uvdynnumerator = v<span class="number">1.</span>uv * v<span class="number">1.</span>Pos.w * dy.x + v<span class="number">2.</span>uv * v<span class="number">2.</span>Pos.w * dy.y + v<span class="number">3.</span>uv * v<span class="number">3.</span>Pos.w * dy.z;<span class="comment">//UV numerator increment in y direction</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Step4"><a href="#Step4" class="headerlink" title="Step4:"></a>Step4:</h4><p>Incrementally update the UV attributes in the x-direction,<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="built_in">floor</span>(curx1); x &lt; <span class="built_in">floor</span>(curx2); x++) &#123;</span><br><span class="line">    <span class="comment">// Incrementally calculate UV oer pixel in the x-direction</span></span><br><span class="line">    uvnumerator = uvnumerator + uvdxnnumerator;</span><br><span class="line">    uvdenominator = uvdenominator + dxdenominator;</span><br><span class="line">    uv = uvnumerator / uvdenominator;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Step5"><a href="#Step5" class="headerlink" title="Step5:"></a>Step5:</h4><p>After the current scanline finishes (all pixels in the x-direction are processed), update the left and right boundaries.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curx1 = curx1 + invslope1;</span><br><span class="line">curx2 = curx2 + invslope2;</span><br></pre></td></tr></table></figure></p>
<h4 id="Step6"><a href="#Step6" class="headerlink" title="Step6:"></a>Step6:</h4><p>INcrementally update the UV attributes in the y-direction (i.e., for each scanline).<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> ymax = <span class="built_in">min</span>(v<span class="number">2.</span>Pos.y, v<span class="number">3.</span>Pos.y);       <span class="comment">// Required because the vertices are from a pre-split triangle</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> scanlineY = <span class="built_in">floor</span>(v<span class="number">1.</span>Pos.y); scanlineY &lt; <span class="built_in">floor</span>(ymax); scanlineY++) &#123;</span><br><span class="line">    <span class="comment">// Incrementally calculate UV per scanline in the y-direction</span></span><br><span class="line">    uvnumerator = v<span class="number">3.</span>uv * v<span class="number">3.</span>Pos.w + uvdynnumerator * (scanlineY - v<span class="number">3.</span>Pos.y) + uvdxnnumerator * (scanlineY - v<span class="number">3.</span>Pos.y) * invslope1;</span><br><span class="line">    uvdenominator = v<span class="number">3.</span>Pos.w + dydenominator * (scanlineY - v<span class="number">3.</span>Pos.y) + dxdenominator * (scanlineY - v<span class="number">3.</span>Pos.y) * invslope1;</span><br><span class="line">    uv = uvnumerator / uvdenominator;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Complete-Code"><a href="#Complete-Code" class="headerlink" title="Complete Code"></a>Complete Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeviceContext::fillBottomFlatTriangle</span><span class="params">(SimpleVertex v1, SimpleVertex v2, SimpleVertex v3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Calculate the inverse slopes of the edges</span></span><br><span class="line">	<span class="type">double</span> invslope1 = (v<span class="number">2.</span>Pos.x - v<span class="number">1.</span>Pos.x) / (v<span class="number">2.</span>Pos.y - v<span class="number">1.</span>Pos.y);</span><br><span class="line">	<span class="type">double</span> invslope2 = (v<span class="number">3.</span>Pos.x - v<span class="number">1.</span>Pos.x) / (v<span class="number">3.</span>Pos.y - v<span class="number">1.</span>Pos.y);</span><br><span class="line">	<span class="type">float</span> curx1 = v<span class="number">1.</span>Pos.x;</span><br><span class="line">	<span class="type">float</span> curx2 = v<span class="number">1.</span>Pos.x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure invslope1 corresponds to the left edge and invslope2 to the right edge</span></span><br><span class="line">	<span class="keyword">if</span> (invslope1 &gt; invslope2) &#123;</span><br><span class="line">		<span class="type">float</span> temp;</span><br><span class="line">		temp = invslope1;</span><br><span class="line">		invslope1 = invslope2;</span><br><span class="line">		invslope2 = temp;</span><br><span class="line">		SimpleVertex temp1;</span><br><span class="line">		temp1 = v2;</span><br><span class="line">		v2 = v3;</span><br><span class="line">		v3 = temp1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Calculate the incremental values for attribute interpolation (perspective correction)</span></span><br><span class="line">	VECTOR4 dx = <span class="built_in">VECTOR4</span>((-v<span class="number">2.</span>Pos.y + v<span class="number">3.</span>Pos.y) / <span class="number">2</span>, (-v<span class="number">3.</span>Pos.y + v<span class="number">1.</span>Pos.y) / <span class="number">2</span>, (-v<span class="number">1.</span>Pos.y + v<span class="number">2.</span>Pos.y) / <span class="number">2</span>, <span class="number">1</span>) / <span class="built_in">CalTriangleArea</span>(v<span class="number">1.</span>Pos, v<span class="number">2.</span>Pos, v<span class="number">3.</span>Pos);</span><br><span class="line">	VECTOR4 dy = <span class="built_in">VECTOR4</span>((-v<span class="number">3.</span>Pos.x + v<span class="number">2.</span>Pos.x) / <span class="number">2</span>, (-v<span class="number">1.</span>Pos.x + v<span class="number">3.</span>Pos.x) / <span class="number">2</span>, (-v<span class="number">2.</span>Pos.x + v<span class="number">1.</span>Pos.x) / <span class="number">2</span>, <span class="number">1</span>) / <span class="built_in">CalTriangleArea</span>(v<span class="number">1.</span>Pos, v<span class="number">2.</span>Pos, v<span class="number">3.</span>Pos);</span><br><span class="line">	<span class="type">float</span> dxdenominator = dx.x * v<span class="number">1.</span>Pos.w + dx.y * v<span class="number">2.</span>Pos.w + dx.z * v<span class="number">3.</span>Pos.w;</span><br><span class="line">	<span class="type">float</span> dydenominator = dy.x * v<span class="number">1.</span>Pos.w + dy.y * v<span class="number">2.</span>Pos.w + dy.z * v<span class="number">3.</span>Pos.w;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize UV coordinates</span></span><br><span class="line">	VECTOR4 uv = v<span class="number">1.</span>uv;</span><br><span class="line">	VECTOR4 uvnumerator = v<span class="number">1.</span>uv * v<span class="number">1.</span>Pos.w;<span class="comment">// Initialize Perspective-correct numerator for UV</span></span><br><span class="line">	<span class="type">float</span> uvdenominator = v<span class="number">1.</span>Pos.w;        <span class="comment">// Initialize Perspective-correct denominator for UV</span></span><br><span class="line">	<span class="comment">// Calculate the increments for UV interpolation</span></span><br><span class="line">	VECTOR4 uvdxnnumerator = v<span class="number">1.</span>uv * v<span class="number">1.</span>Pos.w * dx.x + v<span class="number">2.</span>uv * v<span class="number">2.</span>Pos.w * dx.y + v<span class="number">3.</span>uv * v<span class="number">3.</span>Pos.w * dx.z;<span class="comment">// UV numerator increment in x-direction</span></span><br><span class="line">	VECTOR4 uvdynnumerator = v<span class="number">1.</span>uv * v<span class="number">1.</span>Pos.w * dy.x + v<span class="number">2.</span>uv * v<span class="number">2.</span>Pos.w * dy.y + v<span class="number">3.</span>uv * v<span class="number">3.</span>Pos.w * dy.z;<span class="comment">// UV numerator increment in y-direction</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize normal vector</span></span><br><span class="line">	VECTOR4 Normal = v<span class="number">1.</span>Normal;</span><br><span class="line">	VECTOR4 Normalnumerator = v<span class="number">1.</span>Normal * v<span class="number">1.</span>Pos.w;</span><br><span class="line">	<span class="type">float</span> Normaldenominator = v<span class="number">1.</span>Pos.w;</span><br><span class="line"></span><br><span class="line">	VECTOR4 Normaldxnnumerator = v<span class="number">1.</span>Normal * v<span class="number">1.</span>Pos.w * dx.x + v<span class="number">2.</span>Normal * v<span class="number">2.</span>Pos.w * dx.y + v<span class="number">3.</span>Normal * v<span class="number">3.</span>Pos.w * dx.z;</span><br><span class="line">	VECTOR4 Normaldynnumerator = v<span class="number">1.</span>Normal * v<span class="number">1.</span>Pos.w * dy.x + v<span class="number">2.</span>Normal * v<span class="number">2.</span>Pos.w * dy.y + v<span class="number">3.</span>Normal * v<span class="number">3.</span>Pos.w * dy.z;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize world position</span></span><br><span class="line">	VECTOR4 Pos = v<span class="number">1.</span>PosWorld;</span><br><span class="line">	VECTOR4 Posnumerator = v<span class="number">1.</span>PosWorld * v<span class="number">1.</span>Pos.w;</span><br><span class="line">	<span class="type">float</span> Posdenominator = v<span class="number">1.</span>Pos.w;</span><br><span class="line"></span><br><span class="line">	VECTOR4 Posdxnnumerator = v<span class="number">1.</span>PosWorld * v<span class="number">1.</span>Pos.w * dx.x + v<span class="number">2.</span>PosWorld * v<span class="number">2.</span>Pos.w * dx.y + v<span class="number">3.</span>PosWorld * v<span class="number">3.</span>Pos.w * dx.z;</span><br><span class="line">	VECTOR4 Posdynnumerator = v<span class="number">1.</span>PosWorld * v<span class="number">1.</span>Pos.w * dy.x + v<span class="number">2.</span>PosWorld * v<span class="number">2.</span>Pos.w * dy.y + v<span class="number">3.</span>PosWorld * v<span class="number">3.</span>Pos.w * dy.z;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize TBN matrix</span></span><br><span class="line">	MATRIX TBN = v<span class="number">1.</span>TBN;</span><br><span class="line">	MATRIX TBNnumerator = v<span class="number">1.</span>TBN * v<span class="number">1.</span>Pos.w;</span><br><span class="line">	<span class="type">float</span> TBNdenominator = v<span class="number">1.</span>Pos.w;</span><br><span class="line"></span><br><span class="line">	MATRIX TBNdxnnumerator = v<span class="number">1.</span>TBN * v<span class="number">1.</span>Pos.w * dx.x + v<span class="number">2.</span>TBN * v<span class="number">2.</span>Pos.w * dx.y + v<span class="number">3.</span>TBN * v<span class="number">3.</span>Pos.w * dx.z;</span><br><span class="line">	MATRIX TBNdynnumerator = v<span class="number">1.</span>TBN * v<span class="number">1.</span>Pos.w * dy.x + v<span class="number">2.</span>TBN * v<span class="number">2.</span>Pos.w * dy.y + v<span class="number">3.</span>TBN * v<span class="number">3.</span>Pos.w * dy.z;</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> ymax = <span class="built_in">min</span>(v<span class="number">2.</span>Pos.y, v<span class="number">3.</span>Pos.y);  <span class="comment">// Define the maximum y-coordinate for this scanline</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> scanlineY = <span class="built_in">floor</span>(v<span class="number">1.</span>Pos.y); scanlineY &lt; <span class="built_in">floor</span>(ymax); scanlineY++) &#123;</span><br><span class="line">	    <span class="comment">// Update interpolated attributes along the y-direction for the scanline</span></span><br><span class="line">		uvnumerator = v<span class="number">1.</span>uv * v<span class="number">1.</span>Pos.w + uvdynnumerator * (scanlineY - v<span class="number">1.</span>Pos.y) + uvdxnnumerator * (scanlineY - v<span class="number">1.</span>Pos.y) * invslope1;<span class="comment">//uv</span></span><br><span class="line">		uvdenominator = v<span class="number">1.</span>Pos.w + dydenominator * (scanlineY - v<span class="number">1.</span>Pos.y) + dxdenominator * (scanlineY - v<span class="number">1.</span>Pos.y) * invslope1;</span><br><span class="line">		uv = uvnumerator / uvdenominator;</span><br><span class="line"></span><br><span class="line">		Normalnumerator = v<span class="number">1.</span>Normal * v<span class="number">1.</span>Pos.w + Normaldynnumerator * (scanlineY - v<span class="number">1.</span>Pos.y) + Normaldxnnumerator * (scanlineY - v<span class="number">1.</span>Pos.y) * invslope1;<span class="comment">//normal</span></span><br><span class="line">		Normaldenominator = v<span class="number">1.</span>Pos.w + dydenominator * (scanlineY - v<span class="number">1.</span>Pos.y) + dxdenominator * (scanlineY - v<span class="number">1.</span>Pos.y) * invslope1;</span><br><span class="line">		Normal = Normalnumerator / Normaldenominator;</span><br><span class="line"></span><br><span class="line">		Posnumerator = v<span class="number">1.</span>PosWorld * v<span class="number">1.</span>Pos.w + Posdynnumerator * (scanlineY - v<span class="number">1.</span>Pos.y) + Posdxnnumerator * (scanlineY - v<span class="number">1.</span>Pos.y) * invslope1;<span class="comment">//pos</span></span><br><span class="line">		Posdenominator = v<span class="number">1.</span>Pos.w + dydenominator * (scanlineY - v<span class="number">1.</span>Pos.y) + dxdenominator * (scanlineY - v<span class="number">1.</span>Pos.y) * invslope1;</span><br><span class="line">		Pos = Posnumerator / Posdenominator;</span><br><span class="line"></span><br><span class="line">		TBNnumerator = v<span class="number">1.</span>TBN * v<span class="number">1.</span>Pos.w + TBNdynnumerator * (scanlineY - v<span class="number">1.</span>Pos.y) + TBNdxnnumerator * (scanlineY - v<span class="number">1.</span>Pos.y) * invslope1;<span class="comment">//TBN</span></span><br><span class="line">		TBNdenominator = v<span class="number">1.</span>Pos.w + dydenominator * (scanlineY - v<span class="number">1.</span>Pos.y) + dxdenominator * (scanlineY - v<span class="number">1.</span>Pos.y) * invslope1;</span><br><span class="line">		TBN = TBNnumerator / TBNdenominator;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> x = <span class="built_in">floor</span>(curx1); x &lt; <span class="built_in">floor</span>(curx2); x++) &#123;</span><br><span class="line">		    <span class="comment">// Incrementally update attributes along the x-direction</span></span><br><span class="line">			uvnumerator = uvnumerator + uvdxnnumerator;</span><br><span class="line">			uvdenominator = uvdenominator + dxdenominator;</span><br><span class="line">			uv = uvnumerator / uvdenominator;</span><br><span class="line"></span><br><span class="line">			Normalnumerator = Normalnumerator + Normaldxnnumerator;</span><br><span class="line">			Normaldenominator = Normaldenominator + dxdenominator;</span><br><span class="line">			Normal = Normalnumerator / Normaldenominator;</span><br><span class="line"></span><br><span class="line">			Posnumerator = Posnumerator + Posdxnnumerator;</span><br><span class="line">			Posdenominator = Posdenominator + dxdenominator;</span><br><span class="line">			Pos = Posnumerator / Posdenominator;</span><br><span class="line"></span><br><span class="line">			TBNnumerator = TBNnumerator + TBNdxnnumerator;</span><br><span class="line">			TBNdenominator = TBNdenominator + dxdenominator;</span><br><span class="line">			TBN = TBNnumerator / TBNdenominator;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// Perform pixel shader and depth test</span></span><br><span class="line">			<span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; x &lt; <span class="number">1024</span> &amp;&amp; scanlineY&gt;<span class="number">0</span> &amp;&amp; scanlineY &lt; <span class="number">768</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (uv.x &gt;= <span class="number">0</span> &amp;&amp; uv.x &lt;= <span class="number">1</span> &amp;&amp; uv.y &gt;= <span class="number">0</span> &amp;&amp; uv.y &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">					<span class="type">int</span> z = (<span class="type">int</span>)(<span class="built_in">CalPlanePointZ</span>(v<span class="number">1.</span>Pos, v<span class="number">2.</span>Pos, v<span class="number">3.</span>Pos, <span class="built_in">VECTOR4</span>(x, scanlineY, <span class="number">1</span>, <span class="number">1</span>))*<span class="number">10000000</span>); <span class="comment">// Compute depth value</span></span><br><span class="line">					<span class="keyword">if</span> (z &lt; <span class="keyword">this</span>-&gt;depthstencilview-&gt;texture2d-&gt;data[x][scanlineY].r) &#123;<span class="comment">// Depth test</span></span><br><span class="line">						<span class="keyword">this</span>-&gt;depthstencilview-&gt;texture2d-&gt;data[x][scanlineY].r = z;<span class="comment">// Write to depth buffer</span></span><br><span class="line">						<span class="keyword">this</span>-&gt;rendertargetview-&gt;texture2d-&gt;data[x][scanlineY] = <span class="built_in">PixelShader</span>(uv, Normal, Pos, TBN);<span class="comment">// Execute pixel shader</span></span><br><span class="line">						<span class="comment">//this-&gt;rendertargetview-&gt;texture2d-&gt;data[x][scanlineY] = PixelShader(uv, Normal, Pos, TBN)+ this-&gt;rendertargetview-&gt;texture2d-&gt;data[x][scanlineY];//add blend mode, check out the more draw or miss draw</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Update x boundaries for the next scanline</span></span><br><span class="line">		curx1 = curx1 + invslope1;</span><br><span class="line">		curx2 = curx2 + invslope2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Depth-Testing"><a href="#Depth-Testing" class="headerlink" title="Depth Testing"></a>Depth Testing</h3><ul>
<li>For each pixel, the depth (Z-value) is computed and compared against the depth buffer.</li>
<li>If the computed depth is closer to the camera than the current value in the depth buffer, the pixel is considered visible, and the depth buffer is updated.</li>
</ul>
<h2 id="Pixel-Shader-Execution"><a href="#Pixel-Shader-Execution" class="headerlink" title="Pixel Shader Execution"></a>Pixel Shader Execution</h2><p>Once the pixels to be drawn are identified, the pixel shader (also known as the fragment shader) is executed for each pixel. The resulting color is written to the frame buffer for display.</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://zhangzs11.github.io">Zishuai Zhang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://zhangzs11.github.io/2025/01/06/SoftRender--Triangle%20Rasterization/">https://zhangzs11.github.io/2025/01/06/SoftRender--Triangle%20Rasterization/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/MyAvatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/01/18/GraphicsSystem-Skybox/" title="GraphicsSystem-Skybox"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">GraphicsSystem-Skybox</div></div><div class="info-2"><div class="info-item-1">Skybox RenderingA skybox is a cube-shaped environment texture that surrounds the entire scene, simulating a far-away background. Skybox WorkflowThe skybox rendering process is performed after drawing the scene’s meshed. It involves:  Vertex transformations : A cube is used as the geometry for the skybox. Transform the cube vertices to match the camera’s perspective without considering depth. Sampling a cube texture : Use a texture cube (TextureCube) to display the environment.  Combining...</div></div></div></a><a class="pagination-related" href="/2025/01/06/SoftRender--Wireframe%20Rendering/" title="Software Rasterizer - Wireframe Clipping and Rendering"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">Software Rasterizer - Wireframe Clipping and Rendering</div></div><div class="info-2"><div class="info-item-1">Overview of the Wireframe Rendering ProcessWireframe rendering is the process of representing 3D objects using only their edges, without filling the faces. Wireframe rendering involves three primary steps: vertex transformation, clipping, and line rasterization. Step1 : Vertex TransformationTransform 3D object vertices into a 2D space where they can be displayed on the screen.  Object Space:Vertices are defined relative to the object’s local coordinate system. World Space:Apply a model...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/MyAvatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Zishuai Zhang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">29</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/zhangzs11" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:zhangzs2023@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Introduction-to-Rasterization"><span class="toc-number">1.</span> <span class="toc-text">Introduction to Rasterization</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Vertex-Processing"><span class="toc-number">1.1.</span> <span class="toc-text">Vertex Processing</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Vertex-Shader-Transformation"><span class="toc-number">1.1.1.</span> <span class="toc-text">Vertex Shader Transformation:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Clipping"><span class="toc-number">1.1.2.</span> <span class="toc-text">Clipping:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Perspective-Division"><span class="toc-number">1.1.3.</span> <span class="toc-text">Perspective Division:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Viewport-Transformation"><span class="toc-number">1.1.4.</span> <span class="toc-text">Viewport Transformation:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Triangle-Rasterization"><span class="toc-number">1.2.</span> <span class="toc-text">Triangle Rasterization</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Determining-Covered-Pixels"><span class="toc-number">1.2.1.</span> <span class="toc-text">Determining Covered Pixels:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Interpolating-Attributes"><span class="toc-number">1.2.2.</span> <span class="toc-text">Interpolating Attributes:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Step1"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">Step1:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step2"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">Step2:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step3"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">Step3:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step4"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">Step4:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step5"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">Step5:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step6"><span class="toc-number">1.2.2.6.</span> <span class="toc-text">Step6:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Complete-Code"><span class="toc-number">1.2.3.</span> <span class="toc-text">Complete Code</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Depth-Testing"><span class="toc-number">1.2.4.</span> <span class="toc-text">Depth Testing</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pixel-Shader-Execution"><span class="toc-number">1.3.</span> <span class="toc-text">Pixel Shader Execution</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/20/GraphicsSystem-DeferredRendering/" title="GraphicsSystem-Deferred Rendering">GraphicsSystem-Deferred Rendering</a><time datetime="2025-01-20T21:05:08.640Z" title="Created 2025-01-20 14:05:08">2025-01-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/18/GraphicsSystem-FXAA/" title="GraphicsSystem-FXAA">GraphicsSystem-FXAA</a><time datetime="2025-01-19T05:19:14.585Z" title="Created 2025-01-18 22:19:14">2025-01-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/18/GraphicsSystem-NormalMapping/" title="GraphicsSystem-Normal Mapping">GraphicsSystem-Normal Mapping</a><time datetime="2025-01-18T18:19:54.862Z" title="Created 2025-01-18 11:19:54">2025-01-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/18/GraphicsSystem-Skybox/" title="GraphicsSystem-Skybox">GraphicsSystem-Skybox</a><time datetime="2025-01-18T18:19:22.199Z" title="Created 2025-01-18 11:19:22">2025-01-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/06/SoftRender--Triangle%20Rasterization/" title="Software Rasterizer - Triangle Rasterization">Software Rasterizer - Triangle Rasterization</a><time datetime="2025-01-07T00:14:31.379Z" title="Created 2025-01-06 17:14:31">2025-01-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Zishuai Zhang</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>