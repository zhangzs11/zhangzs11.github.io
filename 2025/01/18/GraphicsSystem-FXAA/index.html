<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>GraphicsSystem-FXAA | Canned Pixels</title><meta name="author" content="Zishuai Zhang,zhangzs2023@163.com"><meta name="copyright" content="Zishuai Zhang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="FXAAThis pixel shader implements Fast Approximate Anti-Aliasing (FXAA), a post-processing technique designed to smooth edges and reduce aliasing in rendered images.This algorithm does not approach the">
<meta property="og:type" content="article">
<meta property="og:title" content="GraphicsSystem-FXAA">
<meta property="og:url" content="https://zhangzs11.github.io/2025/01/18/GraphicsSystem-FXAA/index.html">
<meta property="og:site_name" content="Canned Pixels">
<meta property="og:description" content="FXAAThis pixel shader implements Fast Approximate Anti-Aliasing (FXAA), a post-processing technique designed to smooth edges and reduce aliasing in rendered images.This algorithm does not approach the">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://zhangzs11.github.io/img/MyAvatar.jpg">
<meta property="article:published_time" content="2025-01-19T05:19:14.585Z">
<meta property="article:modified_time" content="2025-01-20T04:55:53.717Z">
<meta property="article:author" content="Zishuai Zhang">
<meta property="article:tag" content="Computer Graphics, D3D, Game Engine Development">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhangzs11.github.io/img/MyAvatar.jpg"><link rel="shortcut icon" href="/img/MyAvatar.jpg"><link rel="canonical" href="https://zhangzs11.github.io/2025/01/18/GraphicsSystem-FXAA/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'GraphicsSystem-FXAA',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background: linear-gradient(20deg, #b9fbc0, #98f5e1, #90dbf4, #cfbaf0);"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/Funny/background_heart_emo.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Canned Pixels</span></a><a class="nav-page-title" href="/"><span class="site-name">GraphicsSystem-FXAA</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">GraphicsSystem-FXAA<a class="post-edit-link" href="null_posts/GraphicsSystem-FXAA.md" title="Edit" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-01-19T05:19:14.585Z" title="Created 2025-01-18 22:19:14">2025-01-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-01-20T04:55:53.717Z" title="Updated 2025-01-19 21:55:53">2025-01-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/EAE-Game-Engineering-II/">EAE Game Engineering II</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="FXAA"><a href="#FXAA" class="headerlink" title="FXAA"></a>FXAA</h1><p>This pixel shader implements <strong>Fast Approximate Anti-Aliasing (FXAA)</strong>, a post-processing technique designed to smooth edges and reduce aliasing in rendered images.<br>This algorithm does not approach the problem from the perspective of geometry or line segments but instead relies solely on the luminance information of the current pixel and its surrounding pixels to detect edges and apply smoothing.</p>
<h2 id="Luminance-Calculation"><a href="#Luminance-Calculation" class="headerlink" title="Luminance Calculation"></a>Luminance Calculation</h2><p>Convert the pixel’s RGB color into a single luminance value, representing its perceived brightness.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">LinearRGBToLuminance</span><span class="params">(float3 LinearRGB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dot</span>(LinearRGB, <span class="built_in">float3</span>(<span class="number">0.212671f</span>, <span class="number">0.715160</span>, <span class="number">0.072169</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Determining-Whether-to-Ally-FXAA-to-the-Current-Pixel"><a href="#Determining-Whether-to-Ally-FXAA-to-the-Current-Pixel" class="headerlink" title="Determining Whether to Ally FXAA to the Current Pixel"></a>Determining Whether to Ally FXAA to the Current Pixel</h2><p>The first step in FXAA involves analyzing the local contrast of the current pixel and its immediate neighbors. By calculating the luminance of the current pixel ant its four directly adjacent(N, S, E, and W), we can determine the local maximum and minimum luminance values. The different between these two values represents <strong>the local contrast</strong>.<br>If the local contrast is below a threshold that is proportional to the maximum luminance, <strong>anti-aliasing is skipped</strong>, as it indicates the pixel is in a flat, non-edge region.<br>Additionally, to avoid unnecessary processing in dark areas (e.g., shadows), a secondary absolute threshold is used. I f the local contrast falls  below this absolute threshold, AA is also skipped.<br>When the thresholds are not met, the shader early exits by directly outputting the current pixel’s color.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">float2 posM = i_fragmentUV;</span><br><span class="line">float4 color = g_TextureInput.<span class="built_in">SampleLevel</span>(g_SamplerLinearClamp, i_fragmentUV, <span class="number">0</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//   N</span></span><br><span class="line"><span class="comment">// W M E</span></span><br><span class="line"><span class="comment">//   S</span></span><br><span class="line"><span class="type">float</span> lumaM = <span class="built_in">LinearRGBToLuminance</span>(color.rgb);</span><br><span class="line"><span class="type">float</span> lumaS = <span class="built_in">LinearRGBToLuminance</span>(g_TextureInput.<span class="built_in">SampleLevel</span>(g_SamplerLinearClamp, posM, <span class="number">0</span>, <span class="built_in">int2</span>(<span class="number">0</span>, <span class="number">1</span>)).rgb);</span><br><span class="line"><span class="type">float</span> lumaE = <span class="built_in">LinearRGBToLuminance</span>(g_TextureInput.<span class="built_in">SampleLevel</span>(g_SamplerLinearClamp, posM, <span class="number">0</span>, <span class="built_in">int2</span>(<span class="number">1</span>, <span class="number">0</span>)).rgb);</span><br><span class="line"><span class="type">float</span> lumaN = <span class="built_in">LinearRGBToLuminance</span>(g_TextureInput.<span class="built_in">SampleLevel</span>(g_SamplerLinearClamp, posM, <span class="number">0</span>, <span class="built_in">int2</span>(<span class="number">0</span>, <span class="number">-1</span>)).rgb);</span><br><span class="line"><span class="type">float</span> lumaW = <span class="built_in">LinearRGBToLuminance</span>(g_TextureInput.<span class="built_in">SampleLevel</span>(g_SamplerLinearClamp, posM, <span class="number">0</span>, <span class="built_in">int2</span>(<span class="number">-1</span>, <span class="number">0</span>)).rgb);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Calculate contrast to determine if anti-aliasing should be applied</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Find the maxinmum and minimum relative luminance among 5 pixels to get contrast</span></span><br><span class="line"><span class="type">float</span> lumaRangeMax = <span class="built_in">max</span>(lumaM, <span class="built_in">max</span>(<span class="built_in">max</span>(lumaW, lumaE), <span class="built_in">max</span>(lumaN, lumaS)));</span><br><span class="line"><span class="type">float</span> lumaRangeMin = <span class="built_in">min</span>(lumaM, <span class="built_in">min</span>(<span class="built_in">min</span>(lumaW, lumaE), <span class="built_in">min</span>(lumaN, lumaS)));</span><br><span class="line"><span class="type">float</span> lumaRange = lumaRangeMax - lumaRangeMin;</span><br><span class="line"><span class="comment">// If the brightness change is below a threshold that is positively correlated with max brightness,</span></span><br><span class="line"><span class="comment">// or below an absolute threshold, it indicates a  non-edge region, so no anti-aliasing is applied</span></span><br><span class="line"><span class="type">bool</span> earlyExit = lumaRange &lt; <span class="built_in">max</span>(g_QualityEdgeThresholdMin, lumaRangeMax * g_QualityEdgeThreshold);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Early exit if threshold is not met</span></span><br><span class="line"><span class="keyword">if</span> (earlyExit) &#123;</span><br><span class="line">    o_color = color;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Setting-the-Thresholds"><a href="#Setting-the-Thresholds" class="headerlink" title="Setting the Thresholds"></a>Setting the Thresholds</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Threshold control for required local contrast</span></span><br><span class="line"><span class="comment">// 0.333 - Very low (faster)</span></span><br><span class="line"><span class="comment">// 0.250 - Low quality</span></span><br><span class="line"><span class="comment">// 0.166 - Default</span></span><br><span class="line"><span class="comment">// 0.125 - High quality</span></span><br><span class="line"><span class="comment">// 0.063 - Very high (slower)</span></span><br><span class="line"><span class="type">float</span> g_QualityEdgeThreshold;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Threshold for ignoring dark areas</span></span><br><span class="line"><span class="comment">// 0.0833 - Default</span></span><br><span class="line"><span class="comment">// 0.0625 - Slightly faster</span></span><br><span class="line"><span class="comment">// 0.0312 - Slower</span></span><br><span class="line"><span class="type">float</span> g_QualityEdgeThresholdMin;</span><br></pre></td></tr></table></figure>
<h2 id="Determining-if-the-Edge-is-Horizontal-or-Vertical"><a href="#Determining-if-the-Edge-is-Horizontal-or-Vertical" class="headerlink" title="Determining if the Edge is Horizontal or Vertical"></a>Determining if the Edge is Horizontal or Vertical</h2><p>To classify the nature of the edge (horizontal or vertical), we analyze the luminance of the current pixel (<code>M</code>) and its surrounding 8 pixels (North, South, East, West, and diagonals).<br>The following formulas calculate <strong>the degree of variation in horizontal and vertical</strong> direction:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Determine if the edge is locally horizontal or vertical</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//           </span></span><br><span class="line"><span class="comment">//  NW N NE          </span></span><br><span class="line"><span class="comment">//  W  M  E</span></span><br><span class="line"><span class="comment">//  WS S SE   </span></span><br><span class="line"><span class="comment">//  edgeHorz = |(NW - W) - (W - WS)| + 2|(N - M) - (M - S)| + |(NE - E) - (E - SE)|</span></span><br><span class="line"><span class="comment">//  edgeVert = |(NE - N) - (N - NW)| + 2|(E - M) - (M - W)| + |(SE - S) - (S - WS)|</span></span><br></pre></td></tr></table></figure><br>Code:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> lumaNW = <span class="built_in">LinearRGBToLuminance</span>(g_TextureInput.<span class="built_in">SampleLevel</span>(g_SamplerLinearClamp, posM, <span class="number">0</span>, <span class="built_in">int2</span>(<span class="number">-1</span>, <span class="number">-1</span>)).rgb);</span><br><span class="line"><span class="type">float</span> lumaSE = <span class="built_in">LinearRGBToLuminance</span>(g_TextureInput.<span class="built_in">SampleLevel</span>(g_SamplerLinearClamp, posM, <span class="number">0</span>, <span class="built_in">int2</span>(<span class="number">1</span>, <span class="number">1</span>)).rgb);</span><br><span class="line"><span class="type">float</span> lumaNE = <span class="built_in">LinearRGBToLuminance</span>(g_TextureInput.<span class="built_in">SampleLevel</span>(g_SamplerLinearClamp, posM, <span class="number">0</span>, <span class="built_in">int2</span>(<span class="number">1</span>, <span class="number">-1</span>)).rgb);</span><br><span class="line"><span class="type">float</span> lumaSW = <span class="built_in">LinearRGBToLuminance</span>(g_TextureInput.<span class="built_in">SampleLevel</span>(g_SamplerLinearClamp, posM, <span class="number">0</span>, <span class="built_in">int2</span>(<span class="number">-1</span>, <span class="number">1</span>)).rgb);</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> lumaNS = lumaN + lumaS;</span><br><span class="line"><span class="type">float</span> lumaWE = lumaW + lumaE;</span><br><span class="line"><span class="type">float</span> lumaNESE = lumaNE + lumaSE;</span><br><span class="line"><span class="type">float</span> lumaNWNE = lumaNW + lumaNE;</span><br><span class="line"><span class="type">float</span> lumaNWSW = lumaNW + lumaSW;</span><br><span class="line"><span class="type">float</span> lumaSWSE = lumaSW + lumaSE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Calculate horizontal and vertical contrast</span></span><br><span class="line"><span class="type">float</span> edgeHorz = <span class="built_in">abs</span>(lumaNWSW - <span class="number">2.0</span> * lumaW) + <span class="built_in">abs</span>(lumaNS - <span class="number">2.0</span> * lumaM) * <span class="number">2.0</span> + <span class="built_in">abs</span>(lumaNESE - <span class="number">2.0</span> * lumaE);</span><br><span class="line"><span class="type">float</span> edgeVert = <span class="built_in">abs</span>(lumaSWSE - <span class="number">2.0</span> * lumaS) + <span class="built_in">abs</span>(lumaWE - <span class="number">2.0</span> * lumaM) * <span class="number">2.0</span> + <span class="built_in">abs</span>(lumaNWNE - <span class="number">2.0</span> * lumaN);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine if it is a local horizontal or vertical edge</span></span><br><span class="line"><span class="type">bool</span> horzSpan = edgeHorz &gt;= edgeVert;</span><br></pre></td></tr></table></figure></p>
<h3 id="Corner-Cases"><a href="#Corner-Cases" class="headerlink" title="Corner Cases:"></a>Corner Cases:</h3><p>For corner edges (e.g., diagonals), FXAA simplifies the logic by treating them as either horizontal or vertical.<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 0 0</span><br><span class="line">0 1 1</span><br><span class="line">0 1 1</span><br></pre></td></tr></table></figure></p>
<h2 id="Calculating-the-Gradient-and-Determining-Edge-Direction"><a href="#Calculating-the-Gradient-and-Determining-Edge-Direction" class="headerlink" title="Calculating the Gradient and Determining Edge Direction"></a>Calculating the Gradient and Determining Edge Direction</h2><p>After classifying the edge as horizontal or vertical, we need to determine how the transition occurs along the edge. For example , a horizontal edge can either be an <strong>upper edge</strong> or a <strong>lower edge</strong>. To identify this, we  calculate the gradients in both directions and use the largest absolute gradient as the defining characteristic of the edge.</p>
<p><strong>Gradient Calculation</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Calculate gradient, determine edge direction</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">float</span> luma1 = horzSpan ? lumaN : lumaW;</span><br><span class="line"><span class="type">float</span> luma2 = horzSpan ? lumaS : lumaE;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> gradient1 = luma1 - lumaM;</span><br><span class="line"><span class="type">float</span> gradient2 = luma2 - lumaM;</span><br><span class="line"><span class="comment">// Compute the gradient in the corresponding directijon and scale it for later comparision</span></span><br><span class="line"><span class="type">float</span> gradientScaled = <span class="built_in">max</span>(<span class="built_in">abs</span>(gradient1), <span class="built_in">abs</span>(gradient2)) * <span class="number">0.25f</span>;</span><br><span class="line"><span class="comment">// Determine which direction is steepset</span></span><br><span class="line"><span class="type">bool</span> is1Steepest = <span class="built_in">abs</span>(gradient1) &gt;= <span class="built_in">abs</span>(gradient2);</span><br></pre></td></tr></table></figure></p>
<p><strong>Move Along the Gradient</strong><br>To refine the edge position, we move the current pixel halfway along the direction of the steepest gradient.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">in <span class="type">const</span> float2 i_fragmentUV : TEXCOORD,</span><br><span class="line">float2 posM = i_fragmentUV;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Move the current pixel by half a texel along the gradient direction</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">float</span> lengthSign = horzSpan ? g_TexelSize_Screen.y : g_TexelSize_Screen.x;</span><br><span class="line">lengthSign = is1Steepest ? -lengthSign : lengthSign;</span><br><span class="line"></span><br><span class="line">float2 posB = posM.xy;</span><br><span class="line"><span class="comment">// Half texel offset</span></span><br><span class="line"><span class="keyword">if</span> (!horzSpan)</span><br><span class="line">    posB.x += lengthSign * <span class="number">0.5</span>;</span><br><span class="line"><span class="keyword">if</span> (horzSpan)</span><br><span class="line">    posB.y += lengthSign * <span class="number">0.5</span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>Calculate Average Luminance</strong><br>At the new position (<code>posB</code>), calculate the average luminance of the two neighboring pixels along the edge<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Calculate the average luminance of the two pixels adjacent to posB</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">float</span> luma3 = luma1 + lumaM;</span><br><span class="line"><span class="type">float</span> luma4 = luma2 + lumaM;</span><br><span class="line"><span class="type">float</span> lumaLocalAvg = luma3;</span><br><span class="line"><span class="keyword">if</span> (!is1Steepest)</span><br><span class="line">    lumaLocalAvg = luma4;</span><br><span class="line">lumaLocalAvg *= <span class="number">0.5f</span>;-</span><br></pre></td></tr></table></figure></p>
<h2 id="Exploring-the-Edge-Direction-Initial-Search"><a href="#Exploring-the-Edge-Direction-Initial-Search" class="headerlink" title="Exploring the Edge Direction: Initial Search"></a>Exploring the Edge Direction: Initial Search</h2><p>We explore both side of the edge along its direction to identify its boundaries. Starting from the refined position (<code>posB</code>), we step outward in both directions (positive and negative) by one texel.<br>At each step, we calculate the luminance at the new positions and compare it with the local average luminance at <code>posB</code><br>If the difference exceed the scaled gradient, we determine that we have reached the edge boundary. Otherwise, the search continues with an increased texel offset.</p>
<p><strong>1. Calculate Offset for Edge Direction:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Traverse to both sides until reaching the end or a non-edge point</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Offset to both sides along the edge</span></span><br><span class="line"><span class="comment">// 0    0    0</span></span><br><span class="line"><span class="comment">// &lt;-  posB -&gt;</span></span><br><span class="line"><span class="comment">// 1    1    1</span></span><br><span class="line">float2 offset;</span><br><span class="line">offset.x = (!horzSpan) ? <span class="number">0.0</span> : g_TexelSize_Screen.x;</span><br><span class="line">offset.y = (horzSpan) ? <span class="number">0.0</span> : g_TexelSize_Screen.y;</span><br></pre></td></tr></table></figure></p>
<p><strong>2. First Steps in Both Directions:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float2 posN = posB - offset * s_SampleDistances[<span class="number">0</span>]; <span class="comment">// Negative direction</span></span><br><span class="line">float2 posP = posB + offset * s_SampleDistances[<span class="number">0</span>]; <span class="comment">// Positive direction</span></span><br></pre></td></tr></table></figure></p>
<p><strong>3. Sample Luminance at the New Positions:</strong><br>Retrieve the luminance values at <code>posN</code> and <code>posP</code> by sampling the texture.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get the luminance values at the offset points and compute the different from the middle point&#x27;s Luminance</span></span><br><span class="line"><span class="type">float</span> lumaEndN = <span class="built_in">LinearRGBToLuminance</span>(g_TextureInput.<span class="built_in">SampleLevel</span>(g_SamplerLinearClamp, posN, <span class="number">0</span>).rgb);</span><br><span class="line"><span class="type">float</span> lumaEndP = <span class="built_in">LinearRGBToLuminance</span>(g_TextureInput.<span class="built_in">SampleLevel</span>(g_SamplerLinearClamp, posP, <span class="number">0</span>).rgb);</span><br></pre></td></tr></table></figure></p>
<p><strong>4. Compare with Local Average:</strong><br>Compute the difference between the luminance at the endpoints (<code>lumaEndN</code>, <code>lumaEndP</code>) and the average luminance at <code>posB</code>.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lumaEndN -= lumaLocalAvg;</span><br><span class="line">lumaEndP -= lumaLocalAvg;</span><br></pre></td></tr></table></figure></p>
<p><strong>5. Check If Edge Boundary is Reached:</strong><br>If the luminance difference exceeds the scaled gradient (<code>gradientScaled</code>), the endpoint is considered an edge boundary.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> gradientScaled = <span class="built_in">max</span>(<span class="built_in">abs</span>(gradient1), <span class="built_in">abs</span>(gradient2)) * <span class="number">0.25f</span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the luminance difference at the endpoints exceeds the local gradient, it indicates the edge has been reached</span></span><br><span class="line"><span class="type">bool</span> doneN = <span class="built_in">abs</span>(lumaEndN) &gt;= gradientScaled;</span><br><span class="line"><span class="type">bool</span> doneP = <span class="built_in">abs</span>(lumaEndP) &gt;= gradientScaled;</span><br><span class="line"><span class="type">bool</span> doneNP = doneN &amp;&amp; doneP;</span><br></pre></td></tr></table></figure></p>
<p><strong>6. Continue Extending if Necessary:</strong><br>If an edge boundary is not reached, extend further by applying the next level of offset (<code>s_SampleDistances[1]</code>)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If the non-edge point is not reached, continue extending along this direction</span></span><br><span class="line"><span class="keyword">if</span> (!doneN)</span><br><span class="line">    posN -= offset * s_SampleDistances[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (!doneP)</span><br><span class="line">    posP += offset * s_SampleDistances[<span class="number">1</span>];</span><br></pre></td></tr></table></figure></p>
<h2 id="Continuing-the-Edge-Traversal"><a href="#Continuing-the-Edge-Traversal" class="headerlink" title="Continuing the Edge Traversal"></a>Continuing the Edge Traversal</h2><p>If one side of the edge has not yet reached its boundary, the traversal continues. For instance, if the left side has already reached its edge boundary, it stops. However, the right side might still require several additional steps before reaching its boundary.<br>Iterative Sampling : The loop continues sampling luminance values at increasing offsets (<code>s_SampleDistances[i]</code>) until both sides (<code>doneN</code> and <code>doneP</code>) reach their edge boundaries.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!doneNP)</span><br><span class="line">&#123;</span><br><span class="line">    [unroll]</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; FXAA_QUALITY__PS; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!doneN)</span><br><span class="line">            lumaEndN = <span class="built_in">LinearRGBToLuminance</span>(g_TextureInput.<span class="built_in">SampleLevel</span>(g_SamplerLinearClamp, posN.xy, <span class="number">0</span>).rgb) - lumaLocalAvg;</span><br><span class="line">        <span class="keyword">if</span> (!doneP)</span><br><span class="line">            lumaEndP = <span class="built_in">LinearRGBToLuminance</span>(g_TextureInput.<span class="built_in">SampleLevel</span>(g_SamplerLinearClamp, posP.xy, <span class="number">0</span>).rgb) - lumaLocalAvg;</span><br><span class="line">        </span><br><span class="line">        doneN = <span class="built_in">abs</span>(lumaEndN) &gt;= gradientScaled;</span><br><span class="line">        doneP = <span class="built_in">abs</span>(lumaEndP) &gt;= gradientScaled;</span><br><span class="line">        doneNP = doneN &amp;&amp; doneP;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (!doneN)</span><br><span class="line">            posN -= offset * s_SampleDistances[i];</span><br><span class="line">        <span class="keyword">if</span> (!doneP)</span><br><span class="line">            posP += offset * s_SampleDistances[i];</span><br><span class="line">        <span class="comment">// Stop if both sides reach the edge</span></span><br><span class="line">        <span class="keyword">if</span> (doneNP)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Handling-Limited-Iterations"><a href="#Handling-Limited-Iterations" class="headerlink" title="Handling Limited Iterations"></a>Handling Limited Iterations</h3><p>In scenarios where traversal is limited to a finite number of iterations, moving only one texel per step may not be sufficient to reach the edge boundary. To address this, FXAA employs a <strong>preset array of offset distances</strong> (<code>s_SampleDistances</code>), which defines progressively larger steps as the iteration count increases. This allows the algorithm to efficiently cover larger areas while maintaining precision.</p>
<h3 id="FXAA-Quality-Presets"><a href="#FXAA-Quality-Presets" class="headerlink" title="FXAA Quality Presets"></a>FXAA Quality Presets</h3><p>FXAA provides different quality levels, each with a preset number of sampling steps and corresponding offset distances. These presets balance performance and visual fidelity:</p>
<h4 id="1-Low-Quality"><a href="#1-Low-Quality" class="headerlink" title="1. Low Quality:"></a>1. Low Quality:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> (FXAA_QUALITY__PRESET == 10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FXAA_QUALITY__PS 3</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">float</span> s_SampleDistances[FXAA_QUALITY__PS] = &#123; <span class="number">1.5</span>, <span class="number">3.0</span>, <span class="number">12.0</span> &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>Provides 3 sublevels with increasing offsets.</li>
<li>Suitable for performance-critical scenarios where moderate quality is acceptable.<h4 id="2-High-Quality"><a href="#2-High-Quality" class="headerlink" title="2. High Quality:"></a>2. High Quality:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> (FXAA_QUALITY__PRESET == 39)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FXAA_QUALITY__PS 12</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">float</span> s_SampleDistances[FXAA_QUALITY__PS] = &#123; <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.5</span>, <span class="number">2.0</span>, <span class="number">2.0</span>, <span class="number">2.0</span>, <span class="number">2.0</span>, <span class="number">4.0</span>, <span class="number">8.0</span> &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
Provides 12 sublevels with finer, incremental offsets.<br>Delivers higher precision by thoroughly exploring the edge at the cost of performance.</li>
</ul>
<h2 id="Estimating-UV-Pixel-Offset"><a href="#Estimating-UV-Pixel-Offset" class="headerlink" title="Estimating UV Pixel Offset"></a>Estimating UV Pixel Offset</h2><p>Next, we calculate the distances from <code>posB</code> to the two endpoints of the edge (<code>posN</code> and <code>posP</code>) and determine which endpoint is closer. Using the distance to the closer endpoint and the total span length (distance between the two endpoints), we compute the <strong>UV offset</strong>. This offset determines how much the UV coordinates of the current pixel should be adjusted to align it with the edge.</p>
<h3 id="Calculating-the-Pixel-Offset"><a href="#Calculating-the-Pixel-Offset" class="headerlink" title="Calculating the Pixel Offset"></a>Calculating the Pixel Offset</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Calculate the distances to the two endpoints</span></span><br><span class="line"><span class="type">float</span> distN = horzSpan ? (posM.x - posN.x) : (posM.y - posN.y);</span><br><span class="line"><span class="type">float</span> distP = horzSpan ? (posP.x - posM.x) : (posP.y - posM.y);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check which endpoint is closer to the current point, take that distance</span></span><br><span class="line"><span class="type">bool</span> directionN = distN &lt; distP;</span><br><span class="line"><span class="type">float</span> dist = <span class="built_in">min</span>(distN, distP);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Distance between the two endpoints</span></span><br><span class="line"><span class="type">float</span> spanLength = (distP + distN);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pixel offset towards the nearest endpoint</span></span><br><span class="line"><span class="type">float</span> pixelOffset = -dist / spanLength + <span class="number">0.5f</span>;</span><br></pre></td></tr></table></figure>
<h3 id="Ensuring-the-Offset-is-Valid"><a href="#Ensuring-the-Offset-is-Valid" class="headerlink" title="Ensuring the Offset is Valid"></a>Ensuring the Offset is Valid</h3><p>Before applying the calculated offset, we perform an additional check to ensure the luminance variation at the endpoints matches the gradient at the current pixel. This prevents overshooting the edge and applying an incorrect offset.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Check if the luminance of the current pixel is less than the average luminance of the two pixels adjacent to posB</span></span><br><span class="line"><span class="type">bool</span> isLumaMSmaller = lumaM &lt; lumaLocalAvg;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine if this is a good edge</span></span><br><span class="line"><span class="type">bool</span> goodSpanN = (lumaEndN &lt; <span class="number">0.0</span>) != isLumaMSmaller;</span><br><span class="line"><span class="type">bool</span> goodSpanP = (lumaEndP &lt; <span class="number">0.0</span>) != isLumaMSmaller;</span><br><span class="line"><span class="type">bool</span> goodSpan = directionN ? goodSpanN : goodSpanP;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If not, do not offset</span></span><br><span class="line"><span class="type">float</span> pixelOffsetGood = goodSpan ? pixelOffset : <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="Subpixel-Anti-Aliasing"><a href="#Subpixel-Anti-Aliasing" class="headerlink" title="Subpixel Anti-Aliasing"></a>Subpixel Anti-Aliasing</h2><p>Subpixel anti-aliasing is another crucial step to handle fine details, such as single-pixel lines that can exhibit noticeable jagged edges on the screen. This technique refines the anti-aliasing process by considering luminance variations within a <strong>3x3 pixel kernel</strong> around the current pixel, enabling smooth transitions even at the subpixel level.</p>
<h3 id="Calculating-Subpixel-Luminance-Variation"><a href="#Calculating-Subpixel-Luminance-Variation" class="headerlink" title="Calculating Subpixel Luminance Variation"></a>Calculating Subpixel Luminance Variation</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Calculate luminance variation over a 3x3 range</span></span><br><span class="line"><span class="comment">//      [1  2  1]</span></span><br><span class="line"><span class="comment">// 1/12 [2 -12 2]</span></span><br><span class="line"><span class="comment">//      [1  2  1]</span></span><br><span class="line"><span class="type">float</span> subpixNSWE = lumaNS + lumaWE;</span><br><span class="line"><span class="type">float</span> subpixNWSWNESE = lumaNWSW + lumaNESE;</span><br><span class="line"><span class="type">float</span> subpixA = (<span class="number">2.0</span> * subpixNSWE + subpixNWSWNESE) * (<span class="number">1.0</span> / <span class="number">12.0</span>) - lumaM;</span><br></pre></td></tr></table></figure>
<h3 id="Computing-the-Subpixel-Offset"><a href="#Computing-the-Subpixel-Offset" class="headerlink" title="Computing the Subpixel Offset"></a>Computing the Subpixel Offset</h3><p>the subpixel offset is calculated based on the luminance variation:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Calculate subpixel offset based on this luminance variation</span></span><br><span class="line"><span class="type">float</span> subpixB = <span class="built_in">saturate</span>(<span class="built_in">abs</span>(subpixA) * (<span class="number">1.0</span> / lumaRange));</span><br><span class="line"><span class="type">float</span> subpixC = (<span class="number">-2.0</span> * subpixB + <span class="number">3.0</span>) * subpixB * subpixB;</span><br><span class="line"><span class="type">float</span> subpix = subpixC * subpixC * g_QualitySubPix;</span><br></pre></td></tr></table></figure></p>
<h3 id="Selecting-the-Final-Offset"><a href="#Selecting-the-Final-Offset" class="headerlink" title="Selecting the Final Offset"></a>Selecting the Final Offset</h3><p>The subpixel offset is then compared to the previously calculated edge offset (<code>pixelOffsetGood</code>), and the larger of the two is chosen for the final adjustment:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Select the largest offset</span></span><br><span class="line"><span class="type">float</span> pixelOffsetSubpix = <span class="built_in">max</span>(pixelOffsetGood, subpix);</span><br></pre></td></tr></table></figure></p>
<h2 id="Final-Sampling"><a href="#Final-Sampling" class="headerlink" title="Final Sampling"></a>Final Sampling</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!horzSpan)</span><br><span class="line">    posM.x += pixelOffsetSubpix * lengthSign;</span><br><span class="line"><span class="keyword">if</span> (horzSpan)</span><br><span class="line">    posM.y += pixelOffsetSubpix * lengthSign;</span><br><span class="line"></span><br><span class="line">o_color =  <span class="built_in">float4</span>(g_TextureInput.<span class="built_in">SampleLevel</span>(g_SamplerLinearClamp, posM, <span class="number">0</span>).xyz, lumaM);</span><br></pre></td></tr></table></figure>
<h3 id="SamplerLinearClamp"><a href="#SamplerLinearClamp" class="headerlink" title="SamplerLinearClamp"></a>SamplerLinearClamp</h3><p><strong>1. Clamp (Boundary Clamping)</strong><br>If the UV coordinates fall outside the [0, 1] range, the sampler clamps them to the nearest valid boundary value. For example:</p>
<ul>
<li>A UV coordinate of -0.2 is clamped to 0.</li>
<li>A UV coordinate of 1.5 is clamped to 1.<br>This clamping prevents texture repetition or out-of-bounds sampling, ensuring that sampling always stays within the valid texture area.</li>
</ul>
<p><strong>2. Linear (Linear Interpolation)</strong><br>If the UV coordinates do not align with the center of a texel (typically lying between four adjacent texels), the sampler performs a <strong>linear interpolation</strong> of the texel values. This process calculates a smooth color value based on the weighted contribution of the nearest four texels:</p>
<ul>
<li>Closer texels to the sampling point have higher weights, contributing more to the final color.</li>
<li>Farther texels have lower weights, contributing less.<br>This interpolation produces smooth transitions between texels, avoiding jagged edges or hard boundaries in the sampled texture.</li>
</ul>
<p><strong>3. LOD (Level of Detail) Selection</strong><br>In the <code>SampleLevel</code> function, the <strong>0</strong> parameter specifies that the <strong>highest resolution mipmap level (level 0)</strong> should be used for sampling. Since FXAA operates at screen resolution and does not require mipmap-based detail reduction, it always samples the most detailed texture layer to ensure maximum clarity.</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://zhangzs11.github.io">Zishuai Zhang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://zhangzs11.github.io/2025/01/18/GraphicsSystem-FXAA/">https://zhangzs11.github.io/2025/01/18/GraphicsSystem-FXAA/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/MyAvatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/01/20/GraphicsSystem-DeferredRendering/" title="GraphicsSystem-Deferred Rendering"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">GraphicsSystem-Deferred Rendering</div></div><div class="info-2"><div class="info-item-1">Deferred Rendering: G-Buffer ConstructionThe first stage of deferred rendering involves constructing the G-Buffer, which stores essential pre-pixel data like normals, albedo, position, and specular properties. Vertex Shader12345678910111213141516171819202122void main(    in const float3 i_vertexPosition_local : POSITION,    in const float2 i_vertexUV : TEXCOORD0,    in const float3 i_vertexNormal : NORMAL,        out float4 o_vertexPosition_projected : SV_POSITION,    out float3...</div></div></div></a><a class="pagination-related" href="/2025/01/18/GraphicsSystem-NormalMapping/" title="GraphicsSystem-Normal Mapping"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">GraphicsSystem-Normal Mapping</div></div><div class="info-2"><div class="info-item-1">Normal MappingNormal mapping is a technique to simulate the appearance of detailed surface geometry on a simpler model by altering the surface normal at the pixel level. Inputs in the Vertex ShaderNormal mapping in the vertex shader relies on specific inputs to calculate the tangent space necessary for lighting calculations. These inputs are:in const float3 i_vertexNormal : NORMAL; in const float3 i_vertexTangent : TANGENT; Why these Inputs are needed?The combination of the normal and...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/MyAvatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Zishuai Zhang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">29</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/zhangzs11" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:zhangzs2023@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#FXAA"><span class="toc-number">1.</span> <span class="toc-text">FXAA</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Luminance-Calculation"><span class="toc-number">1.1.</span> <span class="toc-text">Luminance Calculation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Determining-Whether-to-Ally-FXAA-to-the-Current-Pixel"><span class="toc-number">1.2.</span> <span class="toc-text">Determining Whether to Ally FXAA to the Current Pixel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Setting-the-Thresholds"><span class="toc-number">1.2.1.</span> <span class="toc-text">Setting the Thresholds</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Determining-if-the-Edge-is-Horizontal-or-Vertical"><span class="toc-number">1.3.</span> <span class="toc-text">Determining if the Edge is Horizontal or Vertical</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Corner-Cases"><span class="toc-number">1.3.1.</span> <span class="toc-text">Corner Cases:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Calculating-the-Gradient-and-Determining-Edge-Direction"><span class="toc-number">1.4.</span> <span class="toc-text">Calculating the Gradient and Determining Edge Direction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Exploring-the-Edge-Direction-Initial-Search"><span class="toc-number">1.5.</span> <span class="toc-text">Exploring the Edge Direction: Initial Search</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Continuing-the-Edge-Traversal"><span class="toc-number">1.6.</span> <span class="toc-text">Continuing the Edge Traversal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Handling-Limited-Iterations"><span class="toc-number">1.6.1.</span> <span class="toc-text">Handling Limited Iterations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FXAA-Quality-Presets"><span class="toc-number">1.6.2.</span> <span class="toc-text">FXAA Quality Presets</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Low-Quality"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">1. Low Quality:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-High-Quality"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">2. High Quality:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Estimating-UV-Pixel-Offset"><span class="toc-number">1.7.</span> <span class="toc-text">Estimating UV Pixel Offset</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Calculating-the-Pixel-Offset"><span class="toc-number">1.7.1.</span> <span class="toc-text">Calculating the Pixel Offset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ensuring-the-Offset-is-Valid"><span class="toc-number">1.7.2.</span> <span class="toc-text">Ensuring the Offset is Valid</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Subpixel-Anti-Aliasing"><span class="toc-number">1.8.</span> <span class="toc-text">Subpixel Anti-Aliasing</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Calculating-Subpixel-Luminance-Variation"><span class="toc-number">1.8.1.</span> <span class="toc-text">Calculating Subpixel Luminance Variation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Computing-the-Subpixel-Offset"><span class="toc-number">1.8.2.</span> <span class="toc-text">Computing the Subpixel Offset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Selecting-the-Final-Offset"><span class="toc-number">1.8.3.</span> <span class="toc-text">Selecting the Final Offset</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Final-Sampling"><span class="toc-number">1.9.</span> <span class="toc-text">Final Sampling</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SamplerLinearClamp"><span class="toc-number">1.9.1.</span> <span class="toc-text">SamplerLinearClamp</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/20/GraphicsSystem-DeferredRendering/" title="GraphicsSystem-Deferred Rendering">GraphicsSystem-Deferred Rendering</a><time datetime="2025-01-20T21:05:08.640Z" title="Created 2025-01-20 14:05:08">2025-01-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/18/GraphicsSystem-FXAA/" title="GraphicsSystem-FXAA">GraphicsSystem-FXAA</a><time datetime="2025-01-19T05:19:14.585Z" title="Created 2025-01-18 22:19:14">2025-01-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/18/GraphicsSystem-NormalMapping/" title="GraphicsSystem-Normal Mapping">GraphicsSystem-Normal Mapping</a><time datetime="2025-01-18T18:19:54.862Z" title="Created 2025-01-18 11:19:54">2025-01-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/18/GraphicsSystem-Skybox/" title="GraphicsSystem-Skybox">GraphicsSystem-Skybox</a><time datetime="2025-01-18T18:19:22.199Z" title="Created 2025-01-18 11:19:22">2025-01-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/06/SoftRender--Triangle%20Rasterization/" title="Software Rasterizer - Triangle Rasterization">Software Rasterizer - Triangle Rasterization</a><time datetime="2025-01-07T00:14:31.379Z" title="Created 2025-01-06 17:14:31">2025-01-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Zishuai Zhang</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>