<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CG-Physically Based Rendering | Canned Pixels</title><meta name="author" content="Zishuai Zhang,zhangzs2023@163.com"><meta name="copyright" content="Zishuai Zhang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="What exactly distinguishes a classic renderer from a physically based one?Common Traits of PBR:  Energy Conservation: For example, in blinnfunk algorithm, I can easily increase the size of the specula">
<meta property="og:type" content="article">
<meta property="og:title" content="CG-Physically Based Rendering">
<meta property="og:url" content="https://zhangzs11.github.io/2025/01/25/CG_PBR/index.html">
<meta property="og:site_name" content="Canned Pixels">
<meta property="og:description" content="What exactly distinguishes a classic renderer from a physically based one?Common Traits of PBR:  Energy Conservation: For example, in blinnfunk algorithm, I can easily increase the size of the specula">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://zhangzs11.github.io/img/MyAvatar.jpg">
<meta property="article:published_time" content="2025-01-26T00:04:53.977Z">
<meta property="article:modified_time" content="2025-02-02T23:30:05.631Z">
<meta property="article:author" content="Zishuai Zhang">
<meta property="article:tag" content="Computer Graphics, D3D, Game Engine Development">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhangzs11.github.io/img/MyAvatar.jpg"><link rel="shortcut icon" href="/img/MyAvatar.jpg"><link rel="canonical" href="https://zhangzs11.github.io/2025/01/25/CG_PBR/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CG-Physically Based Rendering',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background: linear-gradient(20deg, #b9fbc0, #98f5e1, #90dbf4, #cfbaf0);"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/Funny/doc_room_pixel.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Canned Pixels</span></a><a class="nav-page-title" href="/"><span class="site-name">CG-Physically Based Rendering</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">CG-Physically Based Rendering<a class="post-edit-link" href="null_posts/CG_PBR.md" title="Edit" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-01-26T00:04:53.977Z" title="Created 2025-01-25 17:04:53">2025-01-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-02-02T23:30:05.631Z" title="Updated 2025-02-02 16:30:05">2025-02-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Compute-Graphics/">Compute Graphics</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="What-exactly-distinguishes-a-classic-renderer-from-a-physically-based-one"><a href="#What-exactly-distinguishes-a-classic-renderer-from-a-physically-based-one" class="headerlink" title="What exactly distinguishes a classic renderer from a physically based one?"></a>What exactly distinguishes a classic renderer from a physically based one?</h1><p>Common Traits of PBR:</p>
<ol>
<li><strong>Energy Conservation</strong>:<br> For example, in blinnfunk algorithm, I can easily increase the size of the specular light while still having it keep the same intensity. This should not happen instead the specular <strong>light should have a lower intensity as it covers a larger area</strong>.</li>
<li><strong>Based on a micro facet model</strong>:<br> Assume that surfaces are made of microscopic faces that perfectly reflect light. If they are not well aligned them <strong>at a microscopic level</strong> they will appear to imperfectly reflect light and thus give the surface a rougher look. The less rougher surface is, the more it is mirror-like and vice versa.</li>
<li><strong>Fresnel Effect:</strong><br> The lower the <strong>viewing angle</strong> on a surface is the better the reflection is. This effect can also be seen on a sphere by noticing the intensity of the specular light changing as the angle to the surface get smaller.<br><strong>Notice:</strong> These traits are more like a guidelines, in some cases they are not fully followed and the model is still considered as PBR.</li>
</ol>
<h1 id="Rendering-Equation"><a href="#Rendering-Equation" class="headerlink" title="Rendering Equation"></a>Rendering Equation</h1><p>The rendering equation is as follows:</p>
<script type="math/tex; mode=display">
L_o(\mathbf{x}, \omega_o, \lambda, t) = L_e(\mathbf{x}, \omega_o, \lambda, t) +
\int_\Omega f_r(\mathbf{x}, \omega_i, \omega_o, \lambda, t) L_i(\mathbf{x}, \omega_i, \lambda, t)
(\omega_i \cdot \mathbf{n}) \, d\omega_i</script><p>Where:</p>
<ul>
<li>$  \mathbf{x} $: Fragment position</li>
<li>$ \omega_o $: Outgoing light direction</li>
<li>$ \omega_i $: Incoming light direction</li>
<li>$ \lambda $: Wavelength</li>
<li>$ t $: Time</li>
<li>$ L_o $: Radiance leaving the surface</li>
<li>$ L_e $: Emitted radiance</li>
<li>$ f_r $: Bidirectional reflectance distribution function (BRDF)</li>
<li>$ L_i $: Radiance arriving at the surface</li>
<li>$ \mathbf{n} $: Surface normal</li>
</ul>
<h2 id="Removing-the-time-and-wavelength-variables"><a href="#Removing-the-time-and-wavelength-variables" class="headerlink" title="Removing the time and wavelength variables"></a>Removing the time and wavelength variables</h2><script type="math/tex; mode=display">
L_o(\mathbf{x}, V) = L_e(\mathbf{x}, V) +
\int_\Omega f_r(\mathbf{x}, L, V) L_i(\mathbf{x}, L) (L \cdot \mathbf{N}) \, dL</script><p>Where:</p>
<ul>
<li>$ \mathbf{x} $: Fragment position</li>
<li>$ V $: View vector</li>
<li>$ L $: Light vector</li>
</ul>
<p>On the left side of the equal sign we have the outgoing light that will hit the camera aka the final color.<br>The first variable on the right side is the emitted light of the object.<br>The second variable on ths right is a integral, which adds up all the lights that are within the top hemisphere of a point x on our mesh. We only be using a limited amount of lights that are infinitely small so each source would only contribute light down a single direction. In other words, a pie by integral welcomes carry greek sum symbol.</p>
<script type="math/tex; mode=display">
\int_\Omega f_r(\mathbf{x}, L, V) L_i(\mathbf{x}, L) (L \cdot \mathbf{N}) \, dL</script><p>change to</p>
<script type="math/tex; mode=display">
\sum_{n} f_r(\mathbf{x}, L_n, V) L_i(\mathbf{x}, L_n) (L_n \cdot \mathbf{N})</script><p>And look at the second function:</p>
<script type="math/tex; mode=display">
L_i(\mathbf{x}, L_n)</script><p>Just the incoming light, if you are using the directional lighting then this would simply be the color of your light, but if you are using point lights or spot lights, you also need to take into account the inverse square law of light intensity.</p>
<p>The final part:</p>
<script type="math/tex; mode=display">
(L_n \cdot \mathbf{N})</script><p>It is present in more old-school algorithms like phong and bling-phong lighting, this simply makes the outgoing light less bright when the angle between surface and the incoming light is shallow. Since the intensity of the light gets stretched across a larger area when shallow the angle.</p>
<h3 id="BRDF"><a href="#BRDF" class="headerlink" title="BRDF"></a>BRDF</h3><p>Back to the first function:</p>
<script type="math/tex; mode=display">
f_r(\mathbf{x}, L_n, V)</script><p>This is called <strong>Bidirectional Reflectance Distribution function</strong> or <strong>brdf</strong>. This is the main function that <strong>brings all the pbr qualities to our shading</strong>.<br>It looks like this:</p>
<script type="math/tex; mode=display">
\text{BRDF} = k_d f_{\text{diffuse}} + k_s f_{\text{specular}}</script><p>On the left side of the edition we have our diffused lighting, while on the right side we have our specular lighting. <em>kd</em> and <em>ks</em> represent the fractions that each type of lighting contributes to the final outgoing light.<br>Because pbr should <strong>conserve energy</strong> , these two should add up to one, aka a hundred percent. It they are above that energy is created from nowhere. If they are below that it’s not that bad because you could see that energy is transformed into heat but it’s still undesirable.</p>
<script type="math/tex; mode=display">
k_d+ k_s = 1</script><p>The final effect dictates the amount of specular reflection that takes place so <em>ks</em> would simply equal the <strong>fresnel factor</strong> while kd will equal <strong>one minus ks</strong></p>
<script type="math/tex; mode=display">
k_s = Fresnel</script><script type="math/tex; mode=display">
k_d = 1 - k_s</script><p>The <strong>fresnel function</strong> is this, where $ F_0 $ represents the base reflectivity of a material. So the reflectivity it has when the viewing angle is perpendicular to the surface, the halfway is between the view and light vectors.</p>
<script type="math/tex; mode=display">
F_{\text{Schlick}} = F_0 + (1 - F_0)(1 - (\mathbf{V} \cdot \mathbf{H}))^5</script><p>Where:</p>
<ul>
<li>$ F_0 $: Base reflectivity</li>
<li>$ \mathbf{V} $: View vector</li>
<li>$ \mathbf{H} $: Halfway vector</li>
</ul>
<h3 id="Diffuse"><a href="#Diffuse" class="headerlink" title="Diffuse"></a>Diffuse</h3><p>For the diffuse lighting, we have two choices that i am aware of. One is the <strong>Lambertian Model</strong>, another one the <strong>Oren-Nayar Model</strong>. Oren-Nayar Model gives more realistic results but more computationally expensive. So the Lambertian Model is preferred for real-time graphics.</p>
<h4 id="Lambertian-Model"><a href="#Lambertian-Model" class="headerlink" title="Lambertian Model"></a>Lambertian Model</h4><script type="math/tex; mode=display">
f_{\text{Lambert}} = \frac{\text{color}}{\pi} (\mathbf{L_n} \cdot \mathbf{N})</script><p>Where:</p>
<ul>
<li>$ \text{color} $: Surface color</li>
<li>$ \mathbf{L_n} $: incoming Light vector</li>
<li>$ \mathbf{N} $: Surface normal</li>
</ul>
<p>since we already have this dot product present in the rendering equation we can <strong>omit</strong> it</p>
<h3 id="Specular"><a href="#Specular" class="headerlink" title="Specular"></a>Specular</h3><p>We will be using <strong>Cook-Torrance</strong> or <strong>Torrance-Sparrow</strong></p>
<script type="math/tex; mode=display">
f_{\text{Cook-Torrance}} = \frac{D G F}{4 (\mathbf{V} \cdot \mathbf{N}) (\mathbf{L} \cdot \mathbf{N})}</script><p>Where:</p>
<ul>
<li>$ D $: Normal distribution function</li>
<li>$ G $: Geometry Shadowing(or shadowing-masking) function</li>
<li>$ F $: Fresnel function</li>
<li>$ \mathbf{V} $: View vector</li>
<li>$ \mathbf{L} $: Light vector</li>
<li>$ \mathbf{N} $: Surface normal</li>
</ul>
<p>Since we are using the Cook-Torrance specular lighting function that contains the Fresnel function, we need to get rid of the <em>ks</em> term since otherwise we’d be duplicating the fresnel effect.</p>
<script type="math/tex; mode=display">
\text{BRDF} = k_d f_{\text{diffuse}} + f_{\text{specular}}</script><h4 id="Normal-Distribution-Function"><a href="#Normal-Distribution-Function" class="headerlink" title="Normal Distribution Function"></a>Normal Distribution Function</h4><p>We have the multiple choices such as <strong>Beckmann model, the GGX/Trowbridge-Reitz model, the GGX/Anisotropic model</strong><br>I will use the GGX/Trowbridge-Reitz model, this is the function</p>
<script type="math/tex; mode=display">
\alpha = \text{roughness}^2</script><script type="math/tex; mode=display">
D_{\text{GGX/Trowbridge-Reitz}} = \frac{\alpha^2}{\pi ((\mathbf{N} \cdot \mathbf{H})^2 (\alpha^2 - 1) + 1)^2}</script><p>Where:</p>
<ul>
<li>$ \alpha $: Surface roughness squared</li>
<li>$ \mathbf{N} $: Surface normal</li>
<li>$ \mathbf{H} $: Halfway vector</li>
</ul>
<p>there is a pi in the denominator, this could be removed from here and we put besides the four</p>
<p>What this function basically does is to describe how the micro facets of point we are on or distributed according to their roughness</p>
<h4 id="Geometry-Shadowing-Function"><a href="#Geometry-Shadowing-Function" class="headerlink" title="Geometry Shadowing Function"></a>Geometry Shadowing Function</h4><p>Again, there are multiple models, such as <strong>Neumann model, Kelemen model, smith model, schlick-bechmann model</strong><br>I will use a <strong>combination of the smith and schlick-beckmann models</strong>, that is called <strong>the schlick-GGX</strong> model<br>The smith model takes into account two types of geometrical shadowing interactions. <strong>Geometry obstruction</strong> where the camera can view a little point that it would normally be able to see. <strong>Geometry shadowing</strong> where the light ray isn’t able to reach the camera. Both of these will use the same equation which will be the shclick-beckmann function. The only difference is that for one we will use the view vector while for the other one we will use the light vector  </p>
<script type="math/tex; mode=display">
G_{\text{Smith}} = G_1(\mathbf{L}, \mathbf{N}) G_1(\mathbf{V}, \mathbf{N})</script><p>Where:</p>
<ul>
<li>$ G_1(\mathbf{L}, \mathbf{N}) $: Geometry function for the light vector and surface normal</li>
<li>$ G_1(\mathbf{V}, \mathbf{N}) $: Geometry function for the view vector and surface normal</li>
</ul>
<p>$ G_1 $ is below:</p>
<script type="math/tex; mode=display">
G_{\text{Schlick-Beckmann}} = \frac{\mathbf{N} \cdot \mathbf{X}}{(\mathbf{N} \cdot \mathbf{X})(1 - k) + k}</script><p>Where:</p>
<ul>
<li>$ k = \frac{\alpha}{2} $</li>
<li>$ \mathbf{X} = \mathbf{V} \text{ or } \mathbf{L} $</li>
<li>$ \alpha $: Surface roughness</li>
<li>$ \mathbf{N} $: Surface normal</li>
<li>$ \mathbf{V} $: View vector</li>
<li>$ \mathbf{L} $: Light vector</li>
</ul>
<h4 id="Fresnel-Function"><a href="#Fresnel-Function" class="headerlink" title="Fresnel Function"></a>Fresnel Function</h4><p>We already looked at that.</p>
<h2 id="Conclude-the-rendering-equation"><a href="#Conclude-the-rendering-equation" class="headerlink" title="Conclude the rendering equation"></a>Conclude the rendering equation</h2><div align="center">
  <img src="/images/CG/pbr_rendering_equation.jpg" alt="Game Screenshot">
  <p>rendering equation</p>
</div>

<h1 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h1><h2 id="General-rules-before-start"><a href="#General-rules-before-start" class="headerlink" title="General rules before start"></a>General rules before start</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. No negative dot products</span></span><br><span class="line"><span class="type">float</span> dotProduct = <span class="built_in">max</span>(<span class="built_in">dot</span>(X, Y), <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. No divisions by 0</span></span><br><span class="line"><span class="type">float</span> division = <span class="number">99.0f</span> / <span class="built_in">max</span> (dotProduct, <span class="number">0.000001</span>);</span><br></pre></td></tr></table></figure>
<p>Prevent all negative dot products by having 0 as a minimum value and also to prevent divisions by 0 by having a minimum value (0.000001). The reason we don’t want negative dot products is that it only occur when the vectors are outside of our top hemisphere and anything outside the top hemisphere is ignored in this model.</p>
<h2 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h2><ul>
<li>Normal vector which we get by normalizing the normal, keep in mind that <strong>vertex normals become shorter due to interpolation between vertices</strong></li>
<li>View vector which we can get by normalizing the difference between the camera position and the pixel position</li>
<li>Light vector which we get by normalizing the light position in the case of directional lighting(in directional light, position used to store the direction, no need to store the position) and normalizing the difference between the light position and pixel position in the case of point lights and spotlights</li>
<li>Halfway vector which is obtained by normalizing the addition of the view and light vector.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pixel shader</span></span><br><span class="line"><span class="comment">// Need to be imported in</span></span><br><span class="line">vec3 fragmentPosition;</span><br><span class="line">vec3 normal;</span><br><span class="line">vec3 carmeraPosition;</span><br><span class="line">vec3 lightPosition;</span><br><span class="line">vec3 lightColor;</span><br><span class="line">vec3 albedoMesh;</span><br><span class="line">vec3 emissivityMesh;</span><br><span class="line"><span class="type">float</span> roughness;</span><br><span class="line">vec3 baseReflectance;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main vectors</span></span><br><span class="line">vec3 N = <span class="built_in">normalize</span>(normal);</span><br><span class="line">vec3 V = <span class="built_in">normalize</span>(cameraPosition - fragmentPosition);</span><br><span class="line"><span class="comment">// For directional ligths</span></span><br><span class="line">vec3 L = <span class="built_in">normalize</span>(ligthPosition);</span><br><span class="line"><span class="comment">// For point lights and spot ligths</span></span><br><span class="line">vec3 L = <span class="built_in">normalize</span>(ligthPosition - fragmentPosition);</span><br><span class="line">vec3 H = <span class="built_in">normalize</span>(V + L); </span><br></pre></td></tr></table></figure>
<h2 id="Helper-Function"><a href="#Helper-Function" class="headerlink" title="Helper Function"></a>Helper Function</h2><h3 id="GGX-Trowbridge-Reitz-Normal-Distribution-Function"><a href="#GGX-Trowbridge-Reitz-Normal-Distribution-Function" class="headerlink" title="GGX/Trowbridge-Reitz Normal Distribution Function"></a>GGX/Trowbridge-Reitz Normal Distribution Function</h3><p>Notice how I keep all dot products above 0, and also prevent the division by 0<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">D</span><span class="params">(<span class="type">float</span> alpha, vec3 N, vec3 H)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> numerator = <span class="built_in">pow</span>(alpha, <span class="number">2.0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> NdotH = <span class="built_in">max</span>(<span class="built_in">dot</span>(N, H), <span class="number">0.0</span>);</span><br><span class="line">    <span class="type">float</span> denominator = PI * <span class="built_in">pow</span>(<span class="built_in">pow</span>(NdotH, <span class="number">2.0</span>) * (<span class="built_in">pow</span>(alpha, <span class="number">2.0</span>) - <span class="number">1.0</span>) + <span class="number">1.0</span>, <span class="number">2.0</span>);</span><br><span class="line">    denominator = <span class="built_in">max</span>(denominator, <span class="number">0.000001</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> numerator/denominator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Schilick-Beckmann-Geometry-Shadowing-Function-amp-Smith-Model"><a href="#Schilick-Beckmann-Geometry-Shadowing-Function-amp-Smith-Model" class="headerlink" title="Schilick-Beckmann Geometry Shadowing Function &amp; Smith Model"></a>Schilick-Beckmann Geometry Shadowing Function &amp; Smith Model</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Schilick-Beckmann Geometry Shadowing Function</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">G1</span><span class="params">(<span class="type">float</span> alpha, vec3 N, vec3 X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> numerator = <span class="built_in">max</span>(<span class="built_in">dot</span>(N, X), <span class="number">0.0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> k = alpha / <span class="number">2.0</span>;</span><br><span class="line">    <span class="type">float</span> denominator = <span class="built_in">max</span>(<span class="built_in">dot</span>(N, X), <span class="number">0.0</span>) * (<span class="number">1.0</span> - k) + k;</span><br><span class="line">    denominator = <span class="built_in">max</span>(denominator, <span class="number">0.000001</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> numerator / denominator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Smith Model</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">G</span><span class="params">(<span class="type">float</span> alpha, vec3 N, vec3 V, vec3 L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">G1</span>(alpha, N, V) * <span class="built_in">G1</span>(alpha, N, L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Fresnel-Schlick-Function"><a href="#Fresnel-Schlick-Function" class="headerlink" title="Fresnel-Schlick Function"></a>Fresnel-Schlick Function</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec3 <span class="title">F</span><span class="params">(vec3 F0, vec3 V, vec3 H)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> F0 + (<span class="built_in">vec3</span>(<span class="number">1.0</span>) - F0) * <span class="built_in">pow</span>(<span class="number">1</span> - <span class="built_in">max</span>(<span class="built_in">dot</span>(V, H), <span class="number">0.0</span>), <span class="number">5.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Rendering-Equation-for-one-light-Source"><a href="#Rendering-Equation-for-one-light-Source" class="headerlink" title="Rendering Equation for one light Source"></a>Rendering Equation for one light Source</h2><p>We start by calculating the value of ks and kd, then the lambert equation, and the cook torrence equation, using all these variable we can get the BRDF, don’t forget to omit the ks if you are using cook torrents for specular lighting, and now we can simply plug all the variable we have into the final rendering equation and get the final color.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec3 <span class="title">PBR</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vec3 Ks = <span class="built_in">F</span>(F0, V, H);</span><br><span class="line">vec3 Kd = <span class="built_in">vec3</span>(<span class="number">1.0</span>) - Ks;</span><br><span class="line"></span><br><span class="line">vec3 lambert = albedoMesh / PI;</span><br><span class="line"></span><br><span class="line">vec3 cookTorranceNumerator = <span class="built_in">D</span>(alpha, N, H) * <span class="built_in">G</span>(alpha, N, V, L) * <span class="built_in">F</span>(F0, V, H);</span><br><span class="line"><span class="type">float</span> cookTorranceDenominator = <span class="number">4.0</span> * <span class="built_in">max</span>(<span class="built_in">dot</span>(V, N), <span class="number">0.0</span>) * <span class="built_in">max</span>(<span class="built_in">dot</span>(L, N), <span class="number">0.0</span>);</span><br><span class="line">cookTorranceDenominator = <span class="built_in">max</span>(cookTorranceDenominator, <span class="number">0.000001</span>);</span><br><span class="line">vec3 cookTorrance = cookTorranceNumerator / cookTorranceDenominator;</span><br><span class="line"></span><br><span class="line">vec3 BRDF = Kd * lambert + cookTorrance;</span><br><span class="line">vec3 outgoingLight = emissivityMesh + BRDF * ligthColor * <span class="built_in">max</span>(<span class="built_in">dot</span>(L, N), <span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> outgoingLight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="One-more-thing-metallic-variable"><a href="#One-more-thing-metallic-variable" class="headerlink" title="One more thing: metallic variable"></a>One more thing: metallic variable</h3><p>The special thing about metals is that they only <strong>reflects specular light no diffused light</strong>.<br>We simply have to multiply Kd variable by <strong>1 minus the metallic value</strong>, and don’t forget to also change F0 manually by looking up the base reflectivity of the metal you wish to render or interpolate between some F0 and the albedo of your mesh using the metallic value.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Need to be inported in</span></span><br><span class="line"><span class="type">float</span> metallic;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Make sure to also have an accurate F0</span></span><br><span class="line"><span class="comment">// Or use a &quot;lazy&quot; F0 by using the albedo of the mesh</span></span><br><span class="line"><span class="comment">// Play around with the F0 until you get something you like</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">vec3 Kd = (<span class="built_in">vec3</span>(<span class="number">1.0</span>) - Ks) * (<span class="number">1.0</span> - metallic);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<h2 id="Final-pseudocode"><a href="#Final-pseudocode" class="headerlink" title="Final pseudocode"></a>Final pseudocode</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Import all needed variables</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Define a Normal Distribution Function </span></span><br><span class="line"><span class="comment">// Define a Geometry Shadowing Function</span></span><br><span class="line"><span class="comment">// Define a Fresnel Effect Function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Calculate the Ks variable</span></span><br><span class="line"><span class="comment">// Calculate the Kd variable</span></span><br><span class="line"><span class="comment">// Calculate the diffuse component of the BRDF</span></span><br><span class="line"><span class="comment">// Calculate the specular component of the BRDF</span></span><br><span class="line"><span class="comment">// Combine them into the BRDF</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Insert the BRDF and the other variables into the Rendering Equation</span></span><br><span class="line"><span class="comment">// Output the result of the Rendering Equation </span></span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://zhangzs11.github.io">Zishuai Zhang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://zhangzs11.github.io/2025/01/25/CG_PBR/">https://zhangzs11.github.io/2025/01/25/CG_PBR/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/MyAvatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/01/29/SoftRender-TriangleRasterizationPro/" title="Software Rasterizer - Triangle Rasterization Pro"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">Software Rasterizer - Triangle Rasterization Pro</div></div><div class="info-2"><div class="info-item-1">IntroductionPerfect mathematical triangle that only exists in our minds, but perfect precise triangles they don’t exist in the real world, we need to rasterize in discrete pixel by pixel raster. Scanline rasterizerWe start this problem is we analyze three vertices and then we divide the triangle in the middle, and raster and paint all the pixels from the top vertex until the middle of the triangle and then from the middle until the last vertex.We look at the edges of the triangle, looking at...</div></div></div></a><a class="pagination-related" href="/2025/01/25/CG_HowWriteFastShader/" title="CG-How to Write Fast Shaders"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">CG-How to Write Fast Shaders</div></div><div class="info-2"><div class="info-item-1">Intro12345float4 frag (Varyings input) : SV_Target&#123;    float arg = 27 * length(input.uv - 0.5);    return float4(cos(arg), sin(arg), 0.5, 1);&#125; 1234float4 frag (Varyings input) : SV_Target&#123;    return tex2D(_MainTex, input.uv);&#125; Which one do you think is faster?It is natural to assume that it’s B, because it just grabs the precalculated result, while A does some sort of math. BUt shader B performs at best about the same as A (8 bit INT) and can be much slower (32-bit...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/MyAvatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Zishuai Zhang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">41</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/zhangzs11" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:zhangzs2023@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#What-exactly-distinguishes-a-classic-renderer-from-a-physically-based-one"><span class="toc-number">1.</span> <span class="toc-text">What exactly distinguishes a classic renderer from a physically based one?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Rendering-Equation"><span class="toc-number">2.</span> <span class="toc-text">Rendering Equation</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Removing-the-time-and-wavelength-variables"><span class="toc-number">2.1.</span> <span class="toc-text">Removing the time and wavelength variables</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BRDF"><span class="toc-number">2.1.1.</span> <span class="toc-text">BRDF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Diffuse"><span class="toc-number">2.1.2.</span> <span class="toc-text">Diffuse</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Lambertian-Model"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">Lambertian Model</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Specular"><span class="toc-number">2.1.3.</span> <span class="toc-text">Specular</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Normal-Distribution-Function"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">Normal Distribution Function</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Geometry-Shadowing-Function"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">Geometry Shadowing Function</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Fresnel-Function"><span class="toc-number">2.1.3.3.</span> <span class="toc-text">Fresnel Function</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Conclude-the-rendering-equation"><span class="toc-number">2.2.</span> <span class="toc-text">Conclude the rendering equation</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Implementation"><span class="toc-number">3.</span> <span class="toc-text">Implementation</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#General-rules-before-start"><span class="toc-number">3.1.</span> <span class="toc-text">General rules before start</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Data"><span class="toc-number">3.2.</span> <span class="toc-text">Data</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Helper-Function"><span class="toc-number">3.3.</span> <span class="toc-text">Helper Function</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GGX-Trowbridge-Reitz-Normal-Distribution-Function"><span class="toc-number">3.3.1.</span> <span class="toc-text">GGX&#x2F;Trowbridge-Reitz Normal Distribution Function</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Schilick-Beckmann-Geometry-Shadowing-Function-amp-Smith-Model"><span class="toc-number">3.3.2.</span> <span class="toc-text">Schilick-Beckmann Geometry Shadowing Function &amp; Smith Model</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fresnel-Schlick-Function"><span class="toc-number">3.3.3.</span> <span class="toc-text">Fresnel-Schlick Function</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Rendering-Equation-for-one-light-Source"><span class="toc-number">3.4.</span> <span class="toc-text">Rendering Equation for one light Source</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#One-more-thing-metallic-variable"><span class="toc-number">3.4.1.</span> <span class="toc-text">One more thing: metallic variable</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Final-pseudocode"><span class="toc-number">3.5.</span> <span class="toc-text">Final pseudocode</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/29/SoftRender-TriangleRasterizationPro/" title="Software Rasterizer - Triangle Rasterization Pro">Software Rasterizer - Triangle Rasterization Pro</a><time datetime="2025-01-29T18:17:31.961Z" title="Created 2025-01-29 11:17:31">2025-01-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/25/CG_PBR/" title="CG-Physically Based Rendering">CG-Physically Based Rendering</a><time datetime="2025-01-26T00:04:53.977Z" title="Created 2025-01-25 17:04:53">2025-01-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/25/CG_HowWriteFastShader/" title="CG-How to Write Fast Shaders">CG-How to Write Fast Shaders</a><time datetime="2025-01-25T20:04:44.068Z" title="Created 2025-01-25 13:04:44">2025-01-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/20/GraphicsSystem-DeferredRendering/" title="GraphicsSystem-Deferred Rendering">GraphicsSystem-Deferred Rendering</a><time datetime="2025-01-20T21:05:08.640Z" title="Created 2025-01-20 14:05:08">2025-01-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/18/GraphicsSystem-FXAA/" title="GraphicsSystem-FXAA">GraphicsSystem-FXAA</a><time datetime="2025-01-19T05:19:14.585Z" title="Created 2025-01-18 22:19:14">2025-01-18</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Zishuai Zhang</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>