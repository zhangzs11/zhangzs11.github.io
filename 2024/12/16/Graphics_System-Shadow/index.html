<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>GraphicsSystem-Shadow Mapping | Canned Pixels</title><meta name="author" content="Zishuai Zhang,zhangzs2023@163.com"><meta name="copyright" content="Zishuai Zhang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Shadow mapShadow mapping is a widely used technique in real-time rendering to produce realistic shadows. The process involves placing a camera at the light’s position and rendering the scene from the">
<meta property="og:type" content="article">
<meta property="og:title" content="GraphicsSystem-Shadow Mapping">
<meta property="og:url" content="https://zhangzs11.github.io/2024/12/16/Graphics_System-Shadow/index.html">
<meta property="og:site_name" content="Canned Pixels">
<meta property="og:description" content="Shadow mapShadow mapping is a widely used technique in real-time rendering to produce realistic shadows. The process involves placing a camera at the light’s position and rendering the scene from the">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://zhangzs11.github.io/img/MyAvatar.jpg">
<meta property="article:published_time" content="2024-12-16T07:00:00.000Z">
<meta property="article:modified_time" content="2025-02-05T22:10:05.620Z">
<meta property="article:author" content="Zishuai Zhang">
<meta property="article:tag" content="Computer Graphics, D3D, Game Engine Development">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhangzs11.github.io/img/MyAvatar.jpg"><link rel="shortcut icon" href="/img/MyAvatar.jpg"><link rel="canonical" href="https://zhangzs11.github.io/2024/12/16/Graphics_System-Shadow/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'GraphicsSystem-Shadow Mapping',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background: linear-gradient(20deg, #b9fbc0, #98f5e1, #90dbf4, #cfbaf0);"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/Funny/xuanyuanjian_sea.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Canned Pixels</span></a><a class="nav-page-title" href="/"><span class="site-name">GraphicsSystem-Shadow Mapping</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">GraphicsSystem-Shadow Mapping<a class="post-edit-link" href="null_posts/Graphics_System-Shadow.md" title="Edit" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-12-16T07:00:00.000Z" title="Created 2024-12-16 00:00:00">2024-12-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-02-05T22:10:05.620Z" title="Updated 2025-02-05 15:10:05">2025-02-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Game-Engine/">Game Engine</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Shadow-map"><a href="#Shadow-map" class="headerlink" title="Shadow map"></a>Shadow map</h1><p>Shadow mapping is a widely used technique in real-time rendering to produce realistic shadows. The process involves placing a camera at the light’s position and rendering the scene from the light’s perspective before the main rendering pass. This pre-rendered depth information, stored in a depth buffer, is called the shadow map.</p>
<div align="center">
  <img src="/images/GameEngine/GraphicsSystem/shadow/AShadowMap.png" alt="Game Screenshot">
  <p>A shadow map</p>
</div>

<h2 id="Percentage-Closer-Filtering-PCF"><a href="#Percentage-Closer-Filtering-PCF" class="headerlink" title="Percentage-Closer Filtering (PCF)"></a>Percentage-Closer Filtering (PCF)</h2><p>When sampling the shadow map using projected texture coordinates, it’s common for the sampling point to fall between four texels, rather than directly on one texel. While bilinear interpolation might seem like an intuitive solution, interpolating depth values can produce significant inaccuracies due to the non-linear relationship between the depth values. This can result in incorrect shading, such as falsely marking pixels as shadowed. For this reason, shadow maps don’t use mipmaps either.</p>
<p>Instead of interpolating depth values, Percentage-Closer Filtering (PCF) interpolates the results of depth comparisons. This approach is widely used to smooth shadow edges and reduce aliasing artifacts.</p>
<div align="center">
  <img src="/images/GameEngine/GraphicsSystem/shadow/NoPCF.png" alt="Game Screenshot">
  <p>Shadow Effect without PCF</p>
</div>

<div align="center">
  <img src="/images/GameEngine/GraphicsSystem/shadow/pcf.png" alt="Game Screenshot">
  <p>Shadow Effect with PCF</p>
</div>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">float CalcShadowFactor(SamplerComparisonState samShadow, Texture2D shadowMap, float4 shadowPosH)</span><br><span class="line">&#123;</span><br><span class="line">    // Perspective division</span><br><span class="line">    shadowPosH.xyz /= shadowPosH.w;</span><br><span class="line">    </span><br><span class="line">    // Depth in NDC space</span><br><span class="line">    float depth = shadowPosH.z;</span><br><span class="line"></span><br><span class="line">    float percentLit = 0.0f;</span><br><span class="line">                  </span><br><span class="line">    [unroll]</span><br><span class="line">    for (int i = 0; i &lt; 9; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        percentLit += shadowMap.SampleCmpLevelZero(samShadow,</span><br><span class="line">            shadowPosH.xy, depth, int2(i % 3 - 1, i / 3 - 1)).r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return percentLit /= 9.0f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="PCF-Challenges"><a href="#PCF-Challenges" class="headerlink" title="PCF Challenges"></a>PCF Challenges</h2><ul>
<li>Undersampling: In regions close to the camera, the world-space distance represented by a single shadow map texel can be larger than a pixel in screen space, leading to inaccurate results.</li>
<li>Oversampling: In regions far from the camera, a pixel can represent a larger world-space area than a shadow map texel, resulting in wasted resolution.<br>To address these issues, we can use <strong>Cascaded Shadow Maps (CSMs)</strong>.</li>
</ul>
<h1 id="Cascaded-Shadow-Maps-CSMs"><a href="#Cascaded-Shadow-Maps-CSMs" class="headerlink" title="Cascaded Shadow Maps (CSMs)"></a>Cascaded Shadow Maps (CSMs)</h1><p>CSMs divide the camera’s view frustum into multiple segments (cascades) based on distance. Each cascade generates its own shadow map with a tailored resolution. The closer cascades (near the camera) have higher precision, while farther cascades cover a larger area with lower resolution.</p>
<p>The pixel shader then selects the most appropriate cascade for each fragment based on its distance from the camera.</p>
<div align="center">
  <img src="/images/GameEngine/GraphicsSystem/shadow/CSMPlayerCam.png" alt="Game Screenshot">
  <p>Scene from player camera</p>
</div>

<div align="center">
  <img src="/images/GameEngine/GraphicsSystem/shadow/CSM1.png" alt="Game Screenshot">
  <p>CSM level 1</p>
</div>

<div align="center">
  <img src="/images/GameEngine/GraphicsSystem/shadow/CSM2.png" alt="Game Screenshot">
  <p>CSM level 2</p>
</div>

<div align="center">
  <img src="/images/GameEngine/GraphicsSystem/shadow/CSM3.png" alt="Game Screenshot">
  <p>CSM level 3</p>
</div>

<h2 id="Details-in-Computing-Light-Camera’s-View-Matrix"><a href="#Details-in-Computing-Light-Camera’s-View-Matrix" class="headerlink" title="Details in Computing Light Camera’s View Matrix"></a>Details in Computing Light Camera’s View Matrix</h2><h3 id="PCF-Kernel-Padding"><a href="#PCF-Kernel-Padding" class="headerlink" title="PCF Kernel Padding"></a>PCF Kernel Padding</h3><p>Without padding, the PCF kernel may sample outside the shadow map’s valid region, leading to artifacts. A common solution is to pad the shadow map’s borders with a margin equal to half the PCF kernel size. The following HLSL snippet demonstrates how padding is considered during cascade selection:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Map-Based Selection</span><br><span class="line">// minBoard &lt; tx, ty &lt; maxBoard</span><br><span class="line">    for (int cascadeIndex = 0; cascadeIndex &lt; CASCADE_COUNT_FLAG &amp;&amp; cascadeFound == 0; ++cascadeIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        shadowMapTexCoord = shadowMapTexCoordViewSpace * g_CascadeScale[cascadeIndex] + g_CascadeOffset[cascadeIndex];</span><br><span class="line">        if (min(shadowMapTexCoord.x, shadowMapTexCoord.y) &gt; g_MinBorderPadding</span><br><span class="line">            &amp;&amp; max(shadowMapTexCoord.x, shadowMapTexCoord.y) &lt; g_MaxBorderPadding)</span><br><span class="line">        &#123;</span><br><span class="line">            currentCascadeIndex = cascadeIndex;</span><br><span class="line">            cascadeFound = 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>As the PCF kernel size increases, the required padding grows as well, reducing the usable area of the shadow map. To compensate, the orthographic frustum can be slightly enlarged:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> scaleDuetoBlur = m_PCFKernelSize / (<span class="type">float</span>)m_ShadowSize;</span><br><span class="line">XMVECTORF32 scaleDuetoBlurVec = &#123; &#123;scaleDuetoBlur, scaleDuetoBlur, <span class="number">0.0f</span>, <span class="number">0.0f</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> normalizeByBufferSize = <span class="number">1.0f</span> / m_ShadowSize;</span><br><span class="line">XMVECTORF32 normalizeByBufferSizeVec = &#123; &#123;normalizeByBufferSize, normalizeByBufferSize, <span class="number">0.0f</span>, <span class="number">0.0f</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line">XMVECTOR borderOffsetVec = lightCameraOrthographicMaxVec - lightCameraOrthographicMinVec;</span><br><span class="line">borderOffsetVec *= g_XMOneHalf;</span><br><span class="line">borderOffsetVec *= scaleDuetoBlurVec;</span><br><span class="line">lightCameraOrthographicMaxVec += borderOffsetVec;</span><br><span class="line">lightCameraOrthographicMinVec -= borderOffsetVec;</span><br></pre></td></tr></table></figure>
<h3 id="Preventing-Shadow-Flickering"><a href="#Preventing-Shadow-Flickering" class="headerlink" title="Preventing Shadow Flickering"></a>Preventing Shadow Flickering</h3><p>When PCF is disabled, moving the camera often causes shadow flickering. This is primarily due to changes in the AABB size of the camera frustum’s shadow volume, which alters the pixel-to-texel ratio in the shadow map.</p>
<ul>
<li>Solution Step 1: Fixed AABB Size<br>Using the maximum of the sub-frustum’s diagonal and the far plane’s diagonal as the AABB width and height ensures a stable size.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//     Near    Far</span></span><br><span class="line"><span class="comment">//    0----1  4----5</span></span><br><span class="line"><span class="comment">//    |    |  |    |</span></span><br><span class="line"><span class="comment">//    |    |  |    |</span></span><br><span class="line"><span class="comment">//    3----2  7----6</span></span><br><span class="line">XMVECTOR diagVec = <span class="built_in">XMLoadFloat3</span>(viewerFrustumPoints + <span class="number">7</span>) - <span class="built_in">XMLoadFloat3</span>(viewerFrustumPoints + <span class="number">1</span>);  <span class="comment">// Sub-frustum diagonal</span></span><br><span class="line">XMVECTOR diag2Vec = <span class="built_in">XMLoadFloat3</span>(viewerFrustumPoints + <span class="number">7</span>) - <span class="built_in">XMLoadFloat3</span>(viewerFrustumPoints + <span class="number">5</span>); <span class="comment">// Far-plane of Sub-frustum diagonal</span></span><br><span class="line"></span><br><span class="line">XMVECTOR lengthVec = <span class="built_in">XMVectorMax</span>(<span class="built_in">XMVector3Length</span>(diagVec), <span class="built_in">XMVector3Length</span>(diag2Vec));</span><br></pre></td></tr></table></figure>
<ul>
<li>Solution Step 2: Moving the Light in Texel-Sized Increments<br>To ensure stability, the shadow map’s bounds are aligned with the texel grid. This avoids sub-texel movements causing flickering:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> normalizeByBufferSize = <span class="number">1.0f</span> / m_ShadowSize;</span><br><span class="line">XMVECTORF32 normalizeByBufferSizeVec = &#123; &#123;normalizeByBufferSize, normalizeByBufferSize, <span class="number">0.0f</span>, <span class="number">0.0f</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line">worldUnitsPerTexelVec = lightCameraOrthographicMaxVec - lightCameraOrthographicMinVec;</span><br><span class="line">worldUnitsPerTexelVec *= normalizeByBufferSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Align to texel grid</span></span><br><span class="line">lightCameraOrthographicMinVec /= worldUnitsPerTexelVec;</span><br><span class="line">lightCameraOrthographicMinVec = <span class="built_in">XMVectorFloor</span>(lightCameraOrthographicMinVec);</span><br><span class="line">lightCameraOrthographicMinVec *= worldUnitsPerTexelVec;</span><br><span class="line"></span><br><span class="line">lightCameraOrthographicMaxVec /= worldUnitsPerTexelVec;</span><br><span class="line">lightCameraOrthographicMaxVec = <span class="built_in">XMVectorFloor</span>(lightCameraOrthographicMaxVec);</span><br><span class="line">lightCameraOrthographicMaxVec *= worldUnitsPerTexelVec;</span><br></pre></td></tr></table></figure>
<h2 id="Data-Transmission-for-Cascaded-Shadow-Mapping"><a href="#Data-Transmission-for-Cascaded-Shadow-Mapping" class="headerlink" title="Data Transmission for Cascaded Shadow Mapping"></a>Data Transmission for Cascaded Shadow Mapping</h2><p>In my shadow mapping implementation , the light space view and projection matrices are critical for accurately rendering shadows. Here’s how these matrices are computed and used during the rendering pipeline:</p>
<h3 id="Update-Projection-Matrices-Per-Frame"><a href="#Update-Projection-Matrices-Per-Frame" class="headerlink" title="Update Projection Matrices Per Frame"></a>Update Projection Matrices Per Frame</h3><p>Each frame, the <strong>cascaded shadow manager</strong> recalculates the projection matrices for each cascade using the <code>UpdateFrame</code> function:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line">m_cascadedShadowManager.<span class="built_in">UpdateFrame</span>(m_camera, m_lightCamera, sceneBoundingBox, i_elapsedSecondCount_sinceLastUpdate);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> eae6320::Graphics::cCascadedShadowManager::<span class="built_in">UpdateFrame</span>(<span class="type">const</span> eae6320::Graphics::cCamera&amp; viewerCamera,</span><br><span class="line">                                                            <span class="type">const</span> eae6320::Graphics::cCamera&amp; lightCamera,</span><br><span class="line">                                                            <span class="type">const</span> DirectX::BoundingBox&amp; sceneBoundingBox,</span><br><span class="line">                                                            <span class="type">const</span> <span class="type">float</span> i_elapsedSecondCount_sinceLastUpdate)</span><br><span class="line">&#123;</span><br><span class="line">    Math::cMatrix_transformation ViewerProj = viewerCamera.<span class="built_in">GetCameraToProjectedTransform</span>();</span><br><span class="line">    Math::cMatrix_transformation ViewerView = viewerCamera.<span class="built_in">GetWorldToCameraTransform</span>(i_elapsedSecondCount_sinceLastUpdate);</span><br><span class="line">    Math::cMatrix_transformation LightView = lightCamera.<span class="built_in">GetWorldToCameraTransform</span>(i_elapsedSecondCount_sinceLastUpdate);</span><br><span class="line">    Math::cMatrix_transformation ViewerInvView = ViewerView.<span class="built_in">GetInverse</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> frustumIntervalBegin, frustumIntervalEnd;</span><br><span class="line">    <span class="type">float</span> cameraNearFarRange = viewerCamera.m_z_farPlane - viewerCamera.m_z_nearPlane;</span><br><span class="line"></span><br><span class="line">    DirectX::XMVECTOR worldUnitsPerTexelVec = DirectX::g_XMZero;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Calculate the orthogonal projection matrix in Light space for each cascade</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cascadeIndex = <span class="number">0</span>; cascadeIndex &lt; m_CascadeLevels; ++cascadeIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Calculate the frustum interval covered by the current cascade.</span></span><br><span class="line">        <span class="comment">// We measure the cascade&#x27;s coverage range along the Z-axis by its minimum/maximum distance.</span></span><br><span class="line">        <span class="keyword">if</span> (m_SelectedCascadesFit == FitProjection::FitProjection_ToCascade)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Since we want the orthographic projection matrix to tightly fit around the cascade,</span></span><br><span class="line">            <span class="comment">// we set the beginning of the frustum interval to the end of the previous cascade&#x27;s interval.</span></span><br><span class="line">            <span class="keyword">if</span> (cascadeIndex == <span class="number">0</span>)</span><br><span class="line">                frustumIntervalBegin = <span class="number">0.0f</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                frustumIntervalBegin = m_CascadePartitionsPercentage[cascadeIndex - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// In FIT_PROJECTION_TO_SCENE, these cascades overlap each other.</span></span><br><span class="line">            <span class="comment">// For example, cascades 1-8 cover interval 1,</span></span><br><span class="line">            <span class="comment">// while cascades 2-8 cover interval 2.</span></span><br><span class="line">            frustumIntervalBegin = <span class="number">0.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// the Z begin-end of the frustum</span></span><br><span class="line">        frustumIntervalEnd = m_CascadePartitionsPercentage[cascadeIndex];</span><br><span class="line">        frustumIntervalBegin = frustumIntervalBegin * cameraNearFarRange;</span><br><span class="line">        frustumIntervalEnd = frustumIntervalEnd * cameraNearFarRange;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> frustumVertices = viewerCamera.<span class="built_in">CalculateFrustumVertices</span>(frustumIntervalBegin, frustumIntervalEnd);</span><br><span class="line">        <span class="comment">// Make the frustum from LOCAL space to WORLD space, and then LIGHT space</span></span><br><span class="line">        std::vector&lt;Math::sVector4&gt; lightFrustumVertices;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; vertex : frustumVertices)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">Math::sVector4 <span class="title">vertex4</span><span class="params">(vertex.x, vertex.y, vertex.z, <span class="number">1.0f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">            Math::sVector4 worldSpaceVertex = ViewerInvView * vertex4;</span><br><span class="line"></span><br><span class="line">            Math::sVector4 lightSpaceVertex = LightView * worldSpaceVertex;</span><br><span class="line"></span><br><span class="line">            lightFrustumVertices.<span class="built_in">push_back</span>(lightSpaceVertex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DirectX::XMVECTOR lightCameraOrthographicMinVec = DirectX::<span class="built_in">XMVectorSet</span>(FLT_MAX, FLT_MAX, FLT_MAX, <span class="number">0.0f</span>);</span><br><span class="line">        DirectX::XMVECTOR lightCameraOrthographicMaxVec = DirectX::<span class="built_in">XMVectorSet</span>(-FLT_MAX, -FLT_MAX, -FLT_MAX, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Calculate the AABB, vMax, vMin of frustum in LIGHT space</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; vertex : lightFrustumVertices)</span><br><span class="line">        &#123;</span><br><span class="line">            DirectX::XMVECTOR v = DirectX::<span class="built_in">XMVectorSet</span>(vertex.x, vertex.y, vertex.z, <span class="number">1.0f</span>);</span><br><span class="line">            lightCameraOrthographicMinVec = DirectX::<span class="built_in">XMVectorMin</span>(lightCameraOrthographicMinVec, v);</span><br><span class="line">            lightCameraOrthographicMaxVec = DirectX::<span class="built_in">XMVectorMax</span>(lightCameraOrthographicMaxVec, v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This code can eliminate the flickering effect on shadow edges caused by changed in lighting or camera perspective</span></span><br><span class="line">        <span class="keyword">if</span> (m_FixedSizeFrustumAABB)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//     Near    Far</span></span><br><span class="line">            <span class="comment">//    0----1  4----5</span></span><br><span class="line">            <span class="comment">//    |    |  |    |</span></span><br><span class="line">            <span class="comment">//    |    |  |    |</span></span><br><span class="line">            <span class="comment">//    3----2  7----6</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Near and Far</span></span><br><span class="line">            DirectX::XMVECTOR diagVec = DirectX::<span class="built_in">XMVectorSet</span>(</span><br><span class="line">                frustumVertices[<span class="number">7</span>].x - frustumVertices[<span class="number">0</span>].x,</span><br><span class="line">                frustumVertices[<span class="number">7</span>].y - frustumVertices[<span class="number">0</span>].y,</span><br><span class="line">                frustumVertices[<span class="number">7</span>].z - frustumVertices[<span class="number">0</span>].z,</span><br><span class="line">                <span class="number">0.0f</span></span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Far plane</span></span><br><span class="line">            DirectX::XMVECTOR diag2Vec = DirectX::<span class="built_in">XMVectorSet</span>(</span><br><span class="line">                frustumVertices[<span class="number">7</span>].x - frustumVertices[<span class="number">4</span>].x,</span><br><span class="line">                frustumVertices[<span class="number">7</span>].y - frustumVertices[<span class="number">4</span>].y,</span><br><span class="line">                frustumVertices[<span class="number">7</span>].z - frustumVertices[<span class="number">4</span>].z,</span><br><span class="line">                <span class="number">0.0f</span></span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            DirectX::XMVECTOR lengthVec = DirectX::<span class="built_in">XMVectorMax</span>(DirectX::<span class="built_in">XMVector3Length</span>(diagVec), DirectX::<span class="built_in">XMVector3Length</span>(diag2Vec));</span><br><span class="line">            DirectX::XMVECTOR borderOffsetVec = DirectX::<span class="built_in">XMVectorMultiply</span>(</span><br><span class="line">                DirectX::<span class="built_in">XMVectorSubtract</span>(lengthVec, DirectX::<span class="built_in">XMVectorSubtract</span>(lightCameraOrthographicMaxVec, lightCameraOrthographicMinVec)), </span><br><span class="line">                DirectX::g_XMOneHalf.v);</span><br><span class="line"></span><br><span class="line">            <span class="type">static</span> <span class="type">const</span> DirectX::XMVECTORF32 xyzw1100Vec = &#123; &#123;<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>&#125; &#125;;</span><br><span class="line">            lightCameraOrthographicMaxVec = DirectX::<span class="built_in">XMVectorAdd</span>(lightCameraOrthographicMaxVec, DirectX::<span class="built_in">XMVectorMultiply</span>(borderOffsetVec, xyzw1100Vec.v));</span><br><span class="line">            lightCameraOrthographicMinVec = DirectX::<span class="built_in">XMVectorSubtract</span>(lightCameraOrthographicMinVec, DirectX::<span class="built_in">XMVectorMultiply</span>(borderOffsetVec, xyzw1100Vec.v));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Based on the size of the PCF kernel, we calculate a boundary expansion value to slightlu enlarge the bounding box.</span></span><br><span class="line">        <span class="comment">// The uniform scaling will not affect the previously fixed-size AABB</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">float</span> scaleDuetoBlur = m_PCFKernelSize / (<span class="type">float</span>)m_ShadowSize;</span><br><span class="line">            DirectX::XMVECTORF32 scaleDuetoBlurVec = &#123; &#123;scaleDuetoBlur, scaleDuetoBlur, <span class="number">0.0f</span>, <span class="number">0.0f</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line">            DirectX::XMVECTOR borderOffsetVec = DirectX::<span class="built_in">XMVectorSubtract</span>(lightCameraOrthographicMaxVec, lightCameraOrthographicMinVec);</span><br><span class="line">            borderOffsetVec = DirectX::<span class="built_in">XMVectorMultiply</span>(borderOffsetVec, DirectX::g_XMOneHalf);</span><br><span class="line">            borderOffsetVec = DirectX::<span class="built_in">XMVectorMultiply</span>(borderOffsetVec, scaleDuetoBlurVec);</span><br><span class="line"></span><br><span class="line">            lightCameraOrthographicMaxVec = DirectX::<span class="built_in">XMVectorAdd</span>(lightCameraOrthographicMaxVec, borderOffsetVec);</span><br><span class="line">            lightCameraOrthographicMinVec = DirectX::<span class="built_in">XMVectorSubtract</span>(lightCameraOrthographicMinVec, borderOffsetVec);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_MoveLightTexelSize)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// o_width = 1535;</span></span><br><span class="line">            <span class="comment">// o_height = 1152;</span></span><br><span class="line">            <span class="type">float</span> normalizeByBufferSize = <span class="number">1.0f</span> / (<span class="type">float</span>)m_ShadowSize;</span><br><span class="line">            <span class="comment">// DirectX::XMVECTORF32 normalizeByBufferSizeVec = &#123; &#123;normalizeByBufferSize, normalizeByBufferSize, 0.0f, 0.0f&#125; &#125;;</span></span><br><span class="line">            DirectX::XMVECTORF32 normalizeByBufferSizeVec = &#123; &#123;<span class="number">1.0f</span> / <span class="number">1535.0f</span>, <span class="number">1.0f</span> / <span class="number">1152.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>&#125; &#125;;</span><br><span class="line">            worldUnitsPerTexelVec = DirectX::<span class="built_in">XMVectorSubtract</span>(lightCameraOrthographicMaxVec, lightCameraOrthographicMinVec);</span><br><span class="line">            <span class="comment">// worldUnitsPerTexelVec = DirectX::XMVectorScale(worldUnitsPerTexelVec, normalizeByBufferSize);</span></span><br><span class="line">            worldUnitsPerTexelVec = DirectX::<span class="built_in">XMVectorMultiply</span>(worldUnitsPerTexelVec, normalizeByBufferSizeVec);</span><br><span class="line"></span><br><span class="line">            lightCameraOrthographicMinVec = DirectX::<span class="built_in">XMVectorDivide</span>(lightCameraOrthographicMinVec, worldUnitsPerTexelVec);</span><br><span class="line">            lightCameraOrthographicMinVec = DirectX::<span class="built_in">XMVectorFloor</span>(lightCameraOrthographicMinVec);</span><br><span class="line">            lightCameraOrthographicMinVec = DirectX::<span class="built_in">XMVectorMultiply</span>(lightCameraOrthographicMinVec, worldUnitsPerTexelVec);</span><br><span class="line"></span><br><span class="line">            lightCameraOrthographicMaxVec = DirectX::<span class="built_in">XMVectorDivide</span>(lightCameraOrthographicMaxVec, worldUnitsPerTexelVec);</span><br><span class="line">            lightCameraOrthographicMaxVec = DirectX::<span class="built_in">XMVectorFloor</span>(lightCameraOrthographicMaxVec);</span><br><span class="line">            lightCameraOrthographicMaxVec = DirectX::<span class="built_in">XMVectorMultiply</span>(lightCameraOrthographicMaxVec, worldUnitsPerTexelVec);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> left = DirectX::<span class="built_in">XMVectorGetX</span>(lightCameraOrthographicMinVec);</span><br><span class="line">        <span class="type">float</span> right = DirectX::<span class="built_in">XMVectorGetX</span>(lightCameraOrthographicMaxVec);</span><br><span class="line">        <span class="type">float</span> bottom = DirectX::<span class="built_in">XMVectorGetY</span>(lightCameraOrthographicMinVec);</span><br><span class="line">        <span class="type">float</span> top = DirectX::<span class="built_in">XMVectorGetY</span>(lightCameraOrthographicMaxVec);</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> nearPlane = <span class="number">0.0f</span>;</span><br><span class="line">        <span class="type">float</span> farPlane = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Transform the corner points of the scene AABB into light space</span></span><br><span class="line">        DirectX::XMVECTOR sceneAABBPointsLightSpace[<span class="number">8</span>]&#123;&#125;;</span><br><span class="line">        &#123;</span><br><span class="line">            DirectX::XMFLOAT3 corners[<span class="number">8</span>];</span><br><span class="line">            sceneBoundingBox.<span class="built_in">GetCorners</span>(corners);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                DirectX::XMVECTOR v = <span class="built_in">XMLoadFloat3</span>(corners + i);</span><br><span class="line">                sceneAABBPointsLightSpace[i] = DirectX::<span class="built_in">XMVector3Transform</span>(v, LightView.<span class="built_in">ToXMMATRIX</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_SelectedNearFarFit == FitNearFar::FitNearFar_ZeroOne)</span><br><span class="line">        &#123;</span><br><span class="line">            nearPlane = <span class="number">10.0f</span>;</span><br><span class="line">            farPlane = <span class="number">500.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_SelectedNearFarFit == FitNearFar::FitNearFar_CascadeAABB)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*nearPlane = DirectX::XMVectorGetZ(lightCameraOrthographicMinVec);</span></span><br><span class="line"><span class="comment">            farPlane = DirectX::XMVectorGetZ(lightCameraOrthographicMaxVec);*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m_SelectedNearFarFit == FitNearFar::FitNearFar_SceneAABB)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m_SelectedNearFarFit == FitNearFar::FitNearFar_SceneAABB_Intersection)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// m_ShadowProj</span></span><br><span class="line">        <span class="comment">// Orthographic project matrix</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        m_ShadowProj[cascadeIndex] = Math::cMatrix_transformation::<span class="built_in">CreateCameraToProjectedTransform_orthographic</span>(</span><br><span class="line">            left,</span><br><span class="line">            right,</span><br><span class="line">            bottom,</span><br><span class="line">            top,</span><br><span class="line">            nearPlane,                                             <span class="comment">// nearPlane</span></span><br><span class="line">            farPlane                                               <span class="comment">// farPlane</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Orthographic AABB</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">/*lightCameraOrthographicMinVec = DirectX::XMVectorSetZ(lightCameraOrthographicMinVec, -nearPlane);</span></span><br><span class="line"><span class="comment">        lightCameraOrthographicMaxVec = DirectX::XMVectorSetZ(lightCameraOrthographicMaxVec, -farPlane);</span></span><br><span class="line"><span class="comment">        DirectX::BoundingBox::CreateFromPoints(m_ShadowProjBoundingBox[cascadeIndex],</span></span><br><span class="line"><span class="comment">            lightCameraOrthographicMinVec, lightCameraOrthographicMaxVec);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Partitions of Frustum every Cascade  </span></span><br><span class="line">        m_CascadePartitionsFrustum[cascadeIndex] = frustumIntervalEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h4 id="Step-1-Compute-the-AABB-of-the-Light-Frustum-in-Light-Space"><a href="#Step-1-Compute-the-AABB-of-the-Light-Frustum-in-Light-Space" class="headerlink" title="Step 1: Compute the AABB of the Light Frustum in Light Space"></a>Step 1: Compute the AABB of the Light Frustum in Light Space</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> frustumVertices = viewerCamera.<span class="built_in">CalculateFrustumVertices</span>(frustumIntervalBegin, frustumIntervalEnd);</span><br><span class="line"><span class="comment">// Make the frustum from LOCAL space to WORLD space, and then LIGHT space</span></span><br><span class="line">std::vector&lt;Math::sVector4&gt; lightFrustumVertices;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; vertex : frustumVertices)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Math::sVector4 <span class="title">vertex4</span><span class="params">(vertex.x, vertex.y, vertex.z, <span class="number">1.0f</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    Math::sVector4 worldSpaceVertex = ViewerInvView * vertex4;</span><br><span class="line">    </span><br><span class="line">    Math::sVector4 lightSpaceVertex = LightView * worldSpaceVertex;</span><br><span class="line">    </span><br><span class="line">    lightFrustumVertices.<span class="built_in">push_back</span>(lightSpaceVertex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DirectX::XMVECTOR lightCameraOrthographicMinVec = DirectX::<span class="built_in">XMVectorSet</span>(FLT_MAX, FLT_MAX, FLT_MAX, <span class="number">0.0f</span>);</span><br><span class="line">DirectX::XMVECTOR lightCameraOrthographicMaxVec = DirectX::<span class="built_in">XMVectorSet</span>(-FLT_MAX, -FLT_MAX, -FLT_MAX, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Calculate the AABB, vMax, vMin of frustum in LIGHT space</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; vertex : lightFrustumVertices)</span><br><span class="line">&#123;</span><br><span class="line">    DirectX::XMVECTOR v = DirectX::<span class="built_in">XMVectorSet</span>(vertex.x, vertex.y, vertex.z, <span class="number">1.0f</span>);</span><br><span class="line">    lightCameraOrthographicMinVec = DirectX::<span class="built_in">XMVectorMin</span>(lightCameraOrthographicMinVec, v);</span><br><span class="line">    lightCameraOrthographicMaxVec = DirectX::<span class="built_in">XMVectorMax</span>(lightCameraOrthographicMaxVec, v);</span><br><span class="line">&#125;      </span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<h4 id="Step2-Some-adjustment-like-Align-with-Texels-boundary-expansion-FixedSizeFrustumAABB"><a href="#Step2-Some-adjustment-like-Align-with-Texels-boundary-expansion-FixedSizeFrustumAABB" class="headerlink" title="Step2 : Some adjustment like  Align with Texels, boundary expansion, FixedSizeFrustumAABB"></a>Step2 : Some adjustment like  Align with Texels, boundary expansion, FixedSizeFrustumAABB</h4><h4 id="Step-3-Extract-the-Orthographic-Projection-Bounds"><a href="#Step-3-Extract-the-Orthographic-Projection-Bounds" class="headerlink" title="Step 3: Extract the Orthographic Projection Bounds"></a>Step 3: Extract the Orthographic Projection Bounds</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> left = DirectX::<span class="built_in">XMVectorGetX</span>(lightCameraOrthographicMinVec);</span><br><span class="line"><span class="type">float</span> right = DirectX::<span class="built_in">XMVectorGetX</span>(lightCameraOrthographicMaxVec);</span><br><span class="line"><span class="type">float</span> bottom = DirectX::<span class="built_in">XMVectorGetY</span>(lightCameraOrthographicMinVec);</span><br><span class="line"><span class="type">float</span> top = DirectX::<span class="built_in">XMVectorGetY</span>(lightCameraOrthographicMaxVec);</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> nearPlane = <span class="number">10.0f</span>;   <span class="comment">// A Simplification. using fixed values is fine as long as they cover all objects in the scene.</span></span><br><span class="line"><span class="type">float</span> farPlane = <span class="number">500.0f</span>;</span><br></pre></td></tr></table></figure>
<h4 id="Step-4-Construct-the-Orthographic-Projection-Matrix"><a href="#Step-4-Construct-the-Orthographic-Projection-Matrix" class="headerlink" title="Step 4: Construct the Orthographic Projection Matrix"></a>Step 4: Construct the Orthographic Projection Matrix</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">m_ShadowProj[cascadeIndex] = Math::cMatrix_transformation::<span class="built_in">CreateCameraToProjectedTransform_orthographic</span>(</span><br><span class="line">    left,</span><br><span class="line">    right,</span><br><span class="line">    bottom,</span><br><span class="line">    top,</span><br><span class="line">    nearPlane,     </span><br><span class="line">    farPlane        </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="Orthographics-Projection-in-D3D"><a href="#Orthographics-Projection-in-D3D" class="headerlink" title="Orthographics Projection in D3D"></a>Orthographics Projection in D3D</h3><p>In orthographic projection, the projection matrix transforms vertex positions from view space directly into Normalized Device Coordinates (NDC), where the x, y, and z components fall within a well-defined range. Unlike perspective projection, orthographic projection does not introduce a perspective divide, meaning that after transformation, the vertex shader output is already in NDC space. (<strong>After Orthographics Projection, The w component remains 1, meaning no perspective divide occurs.</strong>)</p>
<h4 id="Using-NDC-for-Shadow-Mapping"><a href="#Using-NDC-for-Shadow-Mapping" class="headerlink" title="Using NDC for Shadow Mapping"></a>Using NDC for Shadow Mapping</h4><p>Since orthographic projection already outputs coordinates in NDC, we can directly use them for shadow map sampling by transforming x and y from [-1, 1] to UV coordinates [0, 1]:</p>
<p>This process adjusts the projection matrices dynamically based on the player’s position and the camera’s view frustum. The resulting projection matrix for a specific cascade is computed as”<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">m_ShadowProj[cascadeIndex] = Math::cMatrix_transformation::<span class="built_in">CreateCameraToProjectedTransform_orthographic</span>(</span><br><span class="line">    left,</span><br><span class="line">    right,</span><br><span class="line">    bottom,</span><br><span class="line">    top,</span><br><span class="line">    nearPlane,</span><br><span class="line">    farPlane</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br><strong>Static View Matrix:</strong> The light camera’s view matrix remains constant throughout the frame, determined by the light’s direction and position.</p>
<h3 id="Rendering-Depth-to-Shadow-Maps"><a href="#Rendering-Depth-to-Shadow-Maps" class="headerlink" title="Rendering Depth to Shadow Maps"></a>Rendering Depth to Shadow Maps</h3><p>When rendering scene depth into the shadow map, each draw call is specific to one cascade and one mesh. This means only the relevant <strong>view</strong> and <strong>projection</strong> matrices for the current cascade need to be transmitted to the GPU:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cbuffer g_constantBuffer_drawCall : <span class="built_in">register</span>(b2)</span><br><span class="line">&#123;</span><br><span class="line">    float4x4 g_World; <span class="comment">// World matrix of the mesh</span></span><br><span class="line">    float4x4 g_View;  <span class="comment">// Light camera&#x27;s view matrix</span></span><br><span class="line">    float4x4 g_Proj;  <span class="comment">// Cascade-specific projection matrix</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>In the vertex shader, the projection matrix is used as follows:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o_vertexPosition_projected = <span class="built_in">mul</span>(g_Proj, <span class="built_in">mul</span>(g_View, <span class="built_in">mul</span>(g_World, <span class="built_in">float4</span>(i_vertexPosition_local, <span class="number">1.0f</span>))));</span><br></pre></td></tr></table></figure></p>
<h3 id="Rendering-the-Main-Scene-with-Cascaded-Shadow-Maps"><a href="#Rendering-the-Main-Scene-with-Cascaded-Shadow-Maps" class="headerlink" title="Rendering the Main Scene with Cascaded Shadow Maps"></a>Rendering the Main Scene with Cascaded Shadow Maps</h3><p>When rendering the main scene and sampling from cascaded shadow maps, instead of transmitting the full projection matrices for all cascades, we compute and pass <strong>offsets</strong> and <strong>scales</strong> for each cascade:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float4 g_CascadeOffset[<span class="number">8</span>];</span><br><span class="line">float4 g_CascadeScale[<span class="number">8</span>];</span><br></pre></td></tr></table></figure></p>
<h3 id="How-to-get-the-offset-and-scale-we-need-and-submit-to-Graphics"><a href="#How-to-get-the-offset-and-scale-we-need-and-submit-to-Graphics" class="headerlink" title="How to get the offset and scale we need, and submit to Graphics"></a>How to get the offset and scale we need, and submit to Graphics</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> eae6320::cMyGame::<span class="built_in">SubmitShadowDataToGraphics</span>(</span><br><span class="line">	eae6320::Graphics::ShadowEffect* i_Shadoweffect,</span><br><span class="line">	<span class="type">const</span> <span class="type">float</span> i_elapsedSecondCount_sinceLastSimulationUpdate)</span><br><span class="line">&#123;</span><br><span class="line">	Math::cMatrix_transformation T = Math::<span class="built_in">cMatrix_transformation</span>(</span><br><span class="line">		<span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">		<span class="number">0.0f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">		<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">		<span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">	Math::sVector4 scales[<span class="number">4</span>];</span><br><span class="line">	Math::sVector4 offsets[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> cascadeIndex = <span class="number">0</span>; cascadeIndex &lt; m_cascadedShadowManager.m_CascadeLevels; ++cascadeIndex)</span><br><span class="line">	&#123;</span><br><span class="line">		Math::cMatrix_transformation ShadowTexture = T * m_cascadedShadowManager.m_ShadowProj[cascadeIndex];</span><br><span class="line"></span><br><span class="line">		scales[cascadeIndex] = Math::<span class="built_in">sVector4</span>(</span><br><span class="line">			ShadowTexture.m_00,  </span><br><span class="line">			ShadowTexture.m_11,  </span><br><span class="line">			ShadowTexture.m_22,  </span><br><span class="line">			<span class="number">1.0f</span>);               </span><br><span class="line"></span><br><span class="line">		offsets[cascadeIndex] = Math::<span class="built_in">sVector4</span>(</span><br><span class="line">			ShadowTexture.m_03,  </span><br><span class="line">			ShadowTexture.m_13,  </span><br><span class="line">			ShadowTexture.m_23,  </span><br><span class="line">			<span class="number">1.0f</span>);               </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> cascadeFrustumsEyeSpaceDepths[<span class="number">4</span>] = &#123; <span class="number">-10.0f</span>, <span class="number">-30.0f</span>, <span class="number">-50.0f</span>, <span class="number">-200.0f</span>&#125;;</span><br><span class="line"></span><br><span class="line">	eae6320::Graphics::<span class="built_in">SubmitShadowData</span>(</span><br><span class="line">		i_Shadoweffect,</span><br><span class="line">		m_lightCamera.<span class="built_in">GetWorldToCameraTransform</span>(i_elapsedSecondCount_sinceLastSimulationUpdate),</span><br><span class="line">		offsets,</span><br><span class="line">		scales,</span><br><span class="line">		cascadeFrustumsEyeSpaceDepths,</span><br><span class="line">		<span class="number">1</span>,         <span class="comment">// Visualize cascades with different colors (1 to enable, 0 to disable)</span></span><br><span class="line">		<span class="number">-2</span>,        <span class="comment">// PCF kernel loop start value (-2 for a 5x5 PCF kernel)</span></span><br><span class="line">		<span class="number">3</span>,         <span class="comment">// PCF kernel loop end value (3 for a 5x5 PCF kernel)</span></span><br><span class="line">		<span class="number">0.01f</span>,     <span class="comment">// Minimum border padding (e.g., (kernelSize / 2) / shadowMapSize)</span></span><br><span class="line">		<span class="number">0.99f</span>,     <span class="comment">// Maximum border padding (e.g., 1.0f - (kernelSize / 2) / shadowMapSize)</span></span><br><span class="line">		<span class="number">0.005f</span>,    <span class="comment">// Shadow bias to reduce shadow artifacts</span></span><br><span class="line">		<span class="number">10.0f</span>,     <span class="comment">// Blend area between cascades</span></span><br><span class="line">		<span class="number">1.0f</span> / <span class="number">1024.0f</span> <span class="comment">// Texel size of the shadow map</span></span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Vertex-Shader-Transforming-World-to-Light-View-Space"><a href="#Vertex-Shader-Transforming-World-to-Light-View-Space" class="headerlink" title="Vertex Shader: Transforming World to Light View Space"></a>Vertex Shader: Transforming World to Light View Space</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o_vertexShadowPosV = <span class="built_in">mul</span>(g_ShadowView, <span class="built_in">float4</span>(o_vertexPosition_world, <span class="number">1.0f</span>));</span><br></pre></td></tr></table></figure>
<h4 id="Pixel-Shader-Transforming-to-Projection-Space"><a href="#Pixel-Shader-Transforming-to-Projection-Space" class="headerlink" title="Pixel Shader: Transforming to Projection Space"></a>Pixel Shader: Transforming to Projection Space</h4><p>In the pixel shader, the light view space coordinate is transformed into the shadow map’s projection space using the cascade-specific <strong>scale</strong> and <strong>offset</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shadowMapTexCoord = shadowMapTexCoordViewSpace * g_CascadeScale[currentCascadeIndex] </span><br><span class="line">                    + g_CascadeOffset[currentCascadeIndex];</span><br></pre></td></tr></table></figure></p>
<h1 id="Next-Step"><a href="#Next-Step" class="headerlink" title="Next Step"></a>Next Step</h1><p>Further improvements in shadow mapping can be explored:</p>
<ul>
<li>Depth Biasing with Large PCF Kernels: Properly balancing shadow bias to prevent Peter-panning and self-shadowing artifacts.</li>
<li>Variance Shadow Maps (VSM): Fixed-size penumbra shadows.</li>
<li>Percentage-Closer Soft Shadows (PCSS): Variable-size penumbra shadows for realistic soft shadows.</li>
<li>Hybrid Techniques: Combining PCSS and VSM for efficient soft shadow rendering.</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://zhangzs11.github.io">Zishuai Zhang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://zhangzs11.github.io/2024/12/16/Graphics_System-Shadow/">https://zhangzs11.github.io/2024/12/16/Graphics_System-Shadow/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/MyAvatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/01/18/GraphicsSystem-Skybox/" title="GraphicsSystem-Skybox"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">GraphicsSystem-Skybox</div></div><div class="info-2"><div class="info-item-1">Skybox RenderingA skybox is a cube-shaped environment texture that surrounds the entire scene, simulating a far-away background. Skybox WorkflowThe skybox rendering process is performed after drawing the scene’s meshed. It involves:  Vertex transformations : A cube is used as the geometry for the skybox. Transform the cube vertices to match the camera’s perspective without considering depth. Sampling a cube texture : Use a texture cube (TextureCube) to display the environment.  Combining...</div></div></div></a><a class="pagination-related" href="/2024/12/02/GameEngineII-FInal%20Project/" title="EAEGameEngineII-Final Game Write-Up"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">EAEGameEngineII-Final Game Write-Up</div></div><div class="info-2"><div class="info-item-1">Final Game Project Write-UpDownload the Game DemoYou can download the demo of the game using the link below. Download Game Demo ZIP How to Control the Game W: Press the W to go forward, remember to avoid being caught by the Monster.  Game OverviewMy final game is inspired by the classic “Red Light, Green Light” game. The gameplay centers around a monster and the player, creating a tense and engaging experience. Objective:The player’s goal is to reach the destination while avoiding being...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/MyAvatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Zishuai Zhang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/zhangzs11" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:zhangzs2023@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Shadow-map"><span class="toc-number">1.</span> <span class="toc-text">Shadow map</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Percentage-Closer-Filtering-PCF"><span class="toc-number">1.1.</span> <span class="toc-text">Percentage-Closer Filtering (PCF)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PCF-Challenges"><span class="toc-number">1.2.</span> <span class="toc-text">PCF Challenges</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Cascaded-Shadow-Maps-CSMs"><span class="toc-number">2.</span> <span class="toc-text">Cascaded Shadow Maps (CSMs)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Details-in-Computing-Light-Camera%E2%80%99s-View-Matrix"><span class="toc-number">2.1.</span> <span class="toc-text">Details in Computing Light Camera’s View Matrix</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PCF-Kernel-Padding"><span class="toc-number">2.1.1.</span> <span class="toc-text">PCF Kernel Padding</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Preventing-Shadow-Flickering"><span class="toc-number">2.1.2.</span> <span class="toc-text">Preventing Shadow Flickering</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Data-Transmission-for-Cascaded-Shadow-Mapping"><span class="toc-number">2.2.</span> <span class="toc-text">Data Transmission for Cascaded Shadow Mapping</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Update-Projection-Matrices-Per-Frame"><span class="toc-number">2.2.1.</span> <span class="toc-text">Update Projection Matrices Per Frame</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Step-1-Compute-the-AABB-of-the-Light-Frustum-in-Light-Space"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">Step 1: Compute the AABB of the Light Frustum in Light Space</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step2-Some-adjustment-like-Align-with-Texels-boundary-expansion-FixedSizeFrustumAABB"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">Step2 : Some adjustment like  Align with Texels, boundary expansion, FixedSizeFrustumAABB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step-3-Extract-the-Orthographic-Projection-Bounds"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">Step 3: Extract the Orthographic Projection Bounds</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step-4-Construct-the-Orthographic-Projection-Matrix"><span class="toc-number">2.2.1.4.</span> <span class="toc-text">Step 4: Construct the Orthographic Projection Matrix</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Orthographics-Projection-in-D3D"><span class="toc-number">2.2.2.</span> <span class="toc-text">Orthographics Projection in D3D</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Using-NDC-for-Shadow-Mapping"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">Using NDC for Shadow Mapping</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rendering-Depth-to-Shadow-Maps"><span class="toc-number">2.2.3.</span> <span class="toc-text">Rendering Depth to Shadow Maps</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rendering-the-Main-Scene-with-Cascaded-Shadow-Maps"><span class="toc-number">2.2.4.</span> <span class="toc-text">Rendering the Main Scene with Cascaded Shadow Maps</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#How-to-get-the-offset-and-scale-we-need-and-submit-to-Graphics"><span class="toc-number">2.2.5.</span> <span class="toc-text">How to get the offset and scale we need, and submit to Graphics</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Vertex-Shader-Transforming-World-to-Light-View-Space"><span class="toc-number">2.2.5.1.</span> <span class="toc-text">Vertex Shader: Transforming World to Light View Space</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pixel-Shader-Transforming-to-Projection-Space"><span class="toc-number">2.2.5.2.</span> <span class="toc-text">Pixel Shader: Transforming to Projection Space</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Next-Step"><span class="toc-number">3.</span> <span class="toc-text">Next Step</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/20/GraphicsSystem-DeferredRendering/" title="GraphicsSystem-Deferred Rendering">GraphicsSystem-Deferred Rendering</a><time datetime="2025-01-20T21:05:08.640Z" title="Created 2025-01-20 14:05:08">2025-01-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/18/GraphicsSystem-FXAA/" title="GraphicsSystem-Anti-Aliasing">GraphicsSystem-Anti-Aliasing</a><time datetime="2025-01-19T05:19:14.585Z" title="Created 2025-01-18 22:19:14">2025-01-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/18/GraphicsSystem-NormalMapping/" title="GraphicsSystem-Normal Mapping">GraphicsSystem-Normal Mapping</a><time datetime="2025-01-18T18:19:54.862Z" title="Created 2025-01-18 11:19:54">2025-01-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/18/GraphicsSystem-Skybox/" title="GraphicsSystem-Skybox">GraphicsSystem-Skybox</a><time datetime="2025-01-18T18:19:22.199Z" title="Created 2025-01-18 11:19:22">2025-01-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/16/Graphics_System-Shadow/" title="GraphicsSystem-Shadow Mapping">GraphicsSystem-Shadow Mapping</a><time datetime="2024-12-16T07:00:00.000Z" title="Created 2024-12-16 00:00:00">2024-12-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Zishuai Zhang</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>